<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="theme-color" content="#1565C0">
  <title>Azul — Board Game</title>
  <style>
/* === css/variables.css === */
/* css/variables.css — Portuguese azulejo-inspired design system */
:root {
  /* Core palette */
  --bg-primary: #0D1B2A;
  --bg-secondary: #1B2838;
  --bg-surface: #243447;
  --bg-surface-light: #2D4055;
  --accent-gold: #C9A84C;
  --accent-blue: #1565C0;
  --accent-blue-light: #42A5F5;
  --text-primary: #E8E4D9;
  --text-secondary: #8FA3B8;
  --text-muted: #5A7084;
  --danger: #E53935;
  --success: #43A047;

  /* Tile colors */
  --tile-blue: #1565C0;
  --tile-yellow: #F9A825;
  --tile-red: #C62828;
  --tile-black: #37474F;
  --tile-white: #ECEFF1;
  --tile-purple: #7B1FA2;
  --tile-green: #2E7D32;
  --tile-orange: #E65100;

  /* Tile sizing */
  --tile-size: 42px;
  --tile-gap: 3px;
  --tile-radius: 6px;

  /* Factory sizing */
  --factory-size: 96px;
  --factory-radius: 50%;

  /* Layout */
  --score-bar-height: 48px;
  --section-padding: 12px;

  /* Animation timing */
  --anim-fast: 150ms;
  --anim-normal: 300ms;
  --anim-slow: 500ms;
  --anim-slide: 600ms;
  --easing-bounce: cubic-bezier(0.34, 1.56, 0.64, 1);
  --easing-smooth: cubic-bezier(0.4, 0, 0.2, 1);

  /* Shadows */
  --shadow-sm: 0 1px 3px rgba(0,0,0,0.3);
  --shadow-md: 0 4px 12px rgba(0,0,0,0.4);
  --shadow-lg: 0 8px 24px rgba(0,0,0,0.5);
  --shadow-glow: 0 0 12px rgba(201, 168, 76, 0.4);
}

@media (min-width: 768px) {
  :root {
    --tile-size: 52px;
    --tile-gap: 4px;
    --factory-size: 120px;
    --section-padding: 20px;
  }
}

@media (min-width: 1024px) {
  :root {
    --tile-size: 56px;
    --factory-size: 130px;
    --section-padding: 24px;
  }
}

/* === css/base.css === */
/* css/base.css — Reset, typography, layout primitives */
@import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Source+Sans+3:wght@300;400;500;600;700&display=swap');

*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html {
  font-size: 16px;
  -webkit-text-size-adjust: 100%;
  -webkit-tap-highlight-color: transparent;
  overflow: hidden;
}

body {
  font-family: 'Source Sans 3', -apple-system, sans-serif;
  background-color: var(--bg-primary);
  color: var(--text-primary);
  line-height: 1.5;
  min-height: 100dvh;
  overflow: hidden;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  user-select: none;
  -webkit-user-select: none;
  touch-action: manipulation;
}

h1, h2, h3 {
  font-family: 'Cinzel', serif;
  font-weight: 600;
  letter-spacing: 0.03em;
}

button {
  font-family: inherit;
  cursor: pointer;
  border: none;
  background: none;
  color: inherit;
  font-size: inherit;
  touch-action: manipulation;
}

img {
  display: block;
  max-width: 100%;
  -webkit-user-drag: none;
}

/* Scrollbar styling */
::-webkit-scrollbar { width: 4px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--text-muted); border-radius: 2px; }

/* Common components */
.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 12px 24px;
  border-radius: 8px;
  font-weight: 600;
  font-size: 1rem;
  transition: all var(--anim-fast) var(--easing-smooth);
  min-height: 48px;
  min-width: 48px;
}

.btn-primary {
  background: linear-gradient(135deg, var(--accent-blue), #1976D2);
  color: white;
  box-shadow: var(--shadow-md);
}
.btn-primary:hover { filter: brightness(1.1); transform: translateY(-1px); }
.btn-primary:active { transform: translateY(0); filter: brightness(0.95); }

.btn-secondary {
  background: var(--bg-surface);
  color: var(--text-primary);
  border: 1px solid var(--text-muted);
}
.btn-secondary:hover { background: var(--bg-surface-light); }

.btn-gold {
  background: linear-gradient(135deg, var(--accent-gold), #D4AF37);
  color: var(--bg-primary);
  font-family: 'Cinzel', serif;
  font-weight: 700;
  box-shadow: var(--shadow-glow);
}
.btn-gold:hover { filter: brightness(1.15); }

.btn-sm { padding: 8px 16px; font-size: 0.875rem; min-height: 36px; }

/* Visually hidden but accessible */
.sr-only {
  position: absolute; width: 1px; height: 1px;
  padding: 0; margin: -1px; overflow: hidden;
  clip: rect(0,0,0,0); white-space: nowrap; border: 0;
}

/* Toast notifications */
.toast-container {
  position: fixed;
  top: calc(var(--score-bar-height) + 8px);
  left: 50%;
  transform: translateX(-50%);
  z-index: 1000;
  display: flex;
  flex-direction: column;
  gap: 8px;
  pointer-events: none;
}

.toast {
  background: var(--bg-surface);
  color: var(--text-primary);
  padding: 10px 20px;
  border-radius: 8px;
  box-shadow: var(--shadow-lg);
  font-weight: 500;
  font-size: 0.9rem;
  animation: toastIn var(--anim-normal) var(--easing-bounce), toastOut var(--anim-normal) var(--easing-smooth) 2.5s forwards;
  border-left: 3px solid var(--accent-gold);
  pointer-events: auto;
  white-space: nowrap;
}

.toast--error { border-left-color: var(--danger); }
.toast--success { border-left-color: var(--success); }

@keyframes toastIn {
  from { opacity: 0; transform: translateY(-20px) scale(0.95); }
  to { opacity: 1; transform: translateY(0) scale(1); }
}
@keyframes toastOut {
  from { opacity: 1; }
  to { opacity: 0; transform: translateY(-10px); }
}

/* Loading spinner */
.loading-overlay {
  position: fixed;
  inset: 0;
  background: var(--bg-primary);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  gap: 16px;
}

.loading-spinner {
  width: 48px; height: 48px;
  border-radius: var(--tile-radius);
  background: var(--accent-blue);
  animation: spinTile 1.2s var(--easing-smooth) infinite;
}

@keyframes spinTile {
  0% { transform: rotate(0deg) scale(1); }
  50% { transform: rotate(180deg) scale(0.8); }
  100% { transform: rotate(360deg) scale(1); }
}

/* === css/tiles.css === */
/* css/tiles.css — Tile appearance, states, selection glow */

.tile {
  width: var(--tile-size);
  height: var(--tile-size);
  border-radius: var(--tile-radius);
  border: 2px solid rgba(255,255,255,0.15);
  position: relative;
  transition: transform var(--anim-fast) var(--easing-smooth),
              box-shadow var(--anim-fast) var(--easing-smooth),
              opacity var(--anim-fast);
  flex-shrink: 0;
  cursor: pointer;
  overflow: hidden;
}

/* Pattern overlay for accessibility (color-blind friendly) */
.tile::after {
  content: '';
  position: absolute;
  inset: 0;
  opacity: 0.25;
  border-radius: inherit;
  pointer-events: none;
}

/* Classic tile colors with patterns */
.tile--blue {
  background: var(--tile-blue);
  box-shadow: inset 0 -2px 4px rgba(0,0,0,0.3);
}
.tile--blue::after {
  background: repeating-linear-gradient(45deg, transparent, transparent 3px, rgba(255,255,255,0.15) 3px, rgba(255,255,255,0.15) 5px);
}

.tile--yellow {
  background: var(--tile-yellow);
  box-shadow: inset 0 -2px 4px rgba(0,0,0,0.2);
}
.tile--yellow::after {
  background: radial-gradient(circle at 50% 50%, rgba(255,255,255,0.2) 2px, transparent 2px);
  background-size: 8px 8px;
}

.tile--red {
  background: var(--tile-red);
  box-shadow: inset 0 -2px 4px rgba(0,0,0,0.3);
}
.tile--red::after {
  background: repeating-linear-gradient(-45deg, transparent, transparent 3px, rgba(255,255,255,0.12) 3px, rgba(255,255,255,0.12) 5px);
}

.tile--black {
  background: var(--tile-black);
  box-shadow: inset 0 -2px 4px rgba(0,0,0,0.4);
}
.tile--black::after {
  background: repeating-linear-gradient(0deg, transparent, transparent 4px, rgba(255,255,255,0.08) 4px, rgba(255,255,255,0.08) 5px);
}

.tile--white {
  background: var(--tile-white);
  border-color: #B0BEC5;
  box-shadow: inset 0 -2px 4px rgba(0,0,0,0.1);
  color: #37474F;
}
.tile--white::after {
  background: repeating-conic-gradient(rgba(0,0,0,0.04) 0% 25%, transparent 0% 50%);
  background-size: 6px 6px;
}

/* Summer Pavilion tiles */
.tile--purple {
  background: var(--tile-purple);
  box-shadow: inset 0 -2px 4px rgba(0,0,0,0.3);
}
.tile--purple::after {
  background: repeating-linear-gradient(135deg, transparent, transparent 4px, rgba(255,255,255,0.12) 4px, rgba(255,255,255,0.12) 6px);
}

.tile--green {
  background: var(--tile-green);
  box-shadow: inset 0 -2px 4px rgba(0,0,0,0.3);
}
.tile--green::after {
  background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.15) 1.5px, transparent 1.5px);
  background-size: 7px 7px;
}

.tile--orange {
  background: var(--tile-orange);
  box-shadow: inset 0 -2px 4px rgba(0,0,0,0.3);
}
.tile--orange::after {
  background: repeating-linear-gradient(90deg, transparent, transparent 3px, rgba(255,255,255,0.1) 3px, rgba(255,255,255,0.1) 5px);
}

/* First player marker */
.tile--first-player {
  background: linear-gradient(135deg, #1B1B1B, #2C2C2C);
  border-color: var(--accent-gold);
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: 'Cinzel', serif;
  font-weight: 700;
  font-size: 0.75em;
  color: var(--accent-gold);
}
.tile--first-player::after { display: none; }
.tile--first-player::before { content: '1'; }

/* Tile states */
.tile--selected {
  transform: scale(1.15);
  box-shadow: 0 0 0 3px var(--accent-gold), var(--shadow-glow);
  z-index: 10;
}

.tile--highlighted {
  animation: highlightPulse 1s ease-in-out infinite;
}

.tile--legal-target {
  animation: legalPulse 1.2s ease-in-out infinite;
  cursor: pointer;
}

.tile--ghost {
  opacity: 0.15;
  cursor: default;
  pointer-events: none;
}

.tile--ghost.tile--placed {
  opacity: 1;
  pointer-events: none;
}

.tile--disabled {
  opacity: 0.4;
  cursor: not-allowed;
  pointer-events: none;
}

.tile--animating {
  position: fixed;
  z-index: 100;
  will-change: transform;
  pointer-events: none;
}

.tile--wild-glow {
  animation: wildGlow 1.5s ease-in-out infinite;
}

/* Tile slot (empty space on pattern line / wall) */
.tile-slot {
  width: var(--tile-size);
  height: var(--tile-size);
  border-radius: var(--tile-radius);
  border: 2px dashed rgba(255,255,255,0.1);
  background: rgba(255,255,255,0.03);
  flex-shrink: 0;
}

.tile-slot--legal {
  border-color: var(--accent-gold);
  background: rgba(201, 168, 76, 0.1);
  animation: legalPulse 1.2s ease-in-out infinite;
  cursor: pointer;
}

.tile-slot--wall {
  border-style: solid;
  border-color: rgba(255,255,255,0.06);
}

@keyframes highlightPulse {
  0%, 100% { box-shadow: 0 0 0 2px rgba(201, 168, 76, 0.4); }
  50% { box-shadow: 0 0 0 4px rgba(201, 168, 76, 0.7), 0 0 16px rgba(201, 168, 76, 0.3); }
}

@keyframes legalPulse {
  0%, 100% { border-color: rgba(201, 168, 76, 0.4); }
  50% { border-color: rgba(201, 168, 76, 0.9); }
}

@keyframes wildGlow {
  0%, 100% { box-shadow: 0 0 6px rgba(255,215,0,0.3); }
  50% { box-shadow: 0 0 16px rgba(255,215,0,0.7), 0 0 24px rgba(255,215,0,0.3); }
}

/* === css/lobby.css === */
/* css/lobby.css — Lobby/menu styles */

.lobby {
  min-height: 100dvh;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 24px var(--section-padding);
  background: var(--bg-primary);
  background-image:
    radial-gradient(ellipse at 20% 50%, rgba(21,101,192,0.08) 0%, transparent 50%),
    radial-gradient(ellipse at 80% 20%, rgba(201,168,76,0.06) 0%, transparent 50%);
  overflow-y: auto;
}

.lobby__header {
  text-align: center;
  margin-bottom: 32px;
  padding-top: 16px;
}

.lobby__title {
  font-family: 'Cinzel', serif;
  font-size: 3rem;
  font-weight: 700;
  background: linear-gradient(135deg, var(--accent-gold), #E8D5A3, var(--accent-gold));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  letter-spacing: 0.15em;
  text-shadow: none;
  filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
}

.lobby__subtitle {
  font-size: 0.9rem;
  color: var(--text-secondary);
  margin-top: 4px;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  font-weight: 300;
}

/* Decorative tile border */
.lobby__tiles-decor {
  display: flex;
  gap: 6px;
  justify-content: center;
  margin: 16px 0 24px;
}
.lobby__tiles-decor .tile {
  width: 28px;
  height: 28px;
  cursor: default;
  opacity: 0.7;
}

/* Main menu panel */
.lobby__panel {
  background: var(--bg-secondary);
  border-radius: 16px;
  padding: 24px;
  width: 100%;
  max-width: 400px;
  box-shadow: var(--shadow-lg);
  border: 1px solid rgba(255,255,255,0.06);
}

.lobby__section {
  margin-bottom: 24px;
}

.lobby__section:last-child {
  margin-bottom: 0;
}

.lobby__section-title {
  font-family: 'Cinzel', serif;
  font-size: 0.85rem;
  text-transform: uppercase;
  letter-spacing: 0.12em;
  color: var(--accent-gold);
  margin-bottom: 12px;
}

/* Variant selector */
.variant-cards {
  display: flex;
  gap: 10px;
}

.variant-card {
  flex: 1;
  background: var(--bg-surface);
  border: 2px solid transparent;
  border-radius: 12px;
  padding: 14px 12px;
  text-align: center;
  transition: all var(--anim-fast) var(--easing-smooth);
  cursor: pointer;
}

.variant-card:hover { background: var(--bg-surface-light); }
.variant-card.selected {
  border-color: var(--accent-blue);
  background: rgba(21,101,192,0.15);
}

.variant-card__name {
  font-weight: 600;
  font-size: 0.95rem;
  margin-bottom: 4px;
}

.variant-card__desc {
  font-size: 0.75rem;
  color: var(--text-secondary);
}

/* Player config */
.player-slots {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.player-slot {
  display: flex;
  align-items: center;
  gap: 10px;
  background: var(--bg-surface);
  border-radius: 10px;
  padding: 10px 14px;
}

.player-slot__number {
  width: 28px;
  height: 28px;
  border-radius: 50%;
  background: var(--accent-blue);
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 700;
  font-size: 0.8rem;
  flex-shrink: 0;
}

.player-slot__name {
  flex: 1;
  background: transparent;
  border: none;
  color: var(--text-primary);
  font-size: 0.95rem;
  font-family: inherit;
  outline: none;
  padding: 4px 0;
  border-bottom: 1px solid var(--text-muted);
}

.player-slot__name:focus {
  border-bottom-color: var(--accent-blue);
}

.player-slot__type {
  background: var(--bg-primary);
  color: var(--text-secondary);
  border: 1px solid var(--text-muted);
  border-radius: 6px;
  padding: 4px 10px;
  font-size: 0.8rem;
  font-family: inherit;
  cursor: pointer;
}

.player-slot__remove {
  color: var(--text-muted);
  font-size: 1.2rem;
  padding: 4px;
  opacity: 0.6;
  transition: opacity var(--anim-fast);
}
.player-slot__remove:hover { opacity: 1; color: var(--danger); }

.add-player-btn {
  width: 100%;
  padding: 10px;
  border-radius: 10px;
  border: 2px dashed var(--text-muted);
  color: var(--text-secondary);
  font-size: 0.9rem;
  transition: all var(--anim-fast);
  margin-top: 8px;
}
.add-player-btn:hover {
  border-color: var(--accent-blue);
  color: var(--accent-blue);
  background: rgba(21,101,192,0.05);
}

/* Start button */
.lobby__start {
  width: 100%;
  margin-top: 8px;
}

/* Online section */
.lobby__online-actions {
  display: flex;
  gap: 10px;
}
.lobby__online-actions .btn {
  flex: 1;
  font-size: 0.9rem;
}

/* Join dialog */
.join-dialog {
  display: none;
  margin-top: 12px;
}
.join-dialog.visible { display: block; }

.join-input {
  width: 100%;
  background: var(--bg-surface);
  border: 1px solid var(--text-muted);
  border-radius: 8px;
  padding: 10px 14px;
  color: var(--text-primary);
  font-size: 1rem;
  font-family: inherit;
  outline: none;
  margin-bottom: 8px;
  text-align: center;
  letter-spacing: 0.2em;
  text-transform: uppercase;
}
.join-input:focus { border-color: var(--accent-blue); }

/* Room waiting */
.room-waiting {
  display: none;
  text-align: center;
  padding: 16px 0;
}
.room-waiting.visible { display: block; }

.room-code {
  font-family: 'Cinzel', serif;
  font-size: 2rem;
  font-weight: 700;
  color: var(--accent-gold);
  letter-spacing: 0.25em;
  margin: 8px 0;
}

.room-link {
  font-size: 0.75rem;
  color: var(--text-muted);
  word-break: break-all;
  background: var(--bg-surface);
  padding: 8px 12px;
  border-radius: 6px;
  margin: 8px 0;
  cursor: pointer;
}

.room-players {
  margin-top: 16px;
}

.room-player {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 6px 0;
  font-size: 0.9rem;
}

.room-player__status {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--success);
}

/* Footer */
.lobby__footer {
  margin-top: auto;
  padding-top: 24px;
  text-align: center;
}

.lobby__footer-links {
  display: flex;
  gap: 16px;
  justify-content: center;
}

.lobby__footer-links button {
  font-size: 0.8rem;
  color: var(--text-muted);
  text-decoration: underline;
}

/* === css/board.css === */
/* css/board.css — Game board layout */

.game-container {
  height: 100dvh;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  background: var(--bg-primary);
}

/* Score bar - always visible at top */
.score-bar {
  height: var(--score-bar-height);
  background: var(--bg-secondary);
  border-bottom: 1px solid rgba(255,255,255,0.06);
  display: flex;
  align-items: center;
  padding: 0 12px;
  gap: 4px;
  z-index: 50;
  flex-shrink: 0;
  overflow-x: auto;
  scrollbar-width: none;
}
.score-bar::-webkit-scrollbar { display: none; }

.score-bar__round {
  font-family: 'Cinzel', serif;
  font-size: 0.7rem;
  color: var(--text-muted);
  white-space: nowrap;
  margin-right: 8px;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  flex-shrink: 0;
}

.score-bar__player {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 4px 10px;
  border-radius: 20px;
  font-size: 0.8rem;
  white-space: nowrap;
  transition: all var(--anim-fast);
  cursor: pointer;
  flex-shrink: 0;
}

.score-bar__player--active {
  background: rgba(201, 168, 76, 0.15);
  color: var(--accent-gold);
}

.score-bar__player--current {
  background: rgba(21, 101, 192, 0.2);
  box-shadow: 0 0 0 1px var(--accent-blue);
}

.score-bar__name {
  max-width: 60px;
  overflow: hidden;
  text-overflow: ellipsis;
  font-weight: 500;
}

.score-bar__score {
  font-weight: 700;
  color: var(--accent-gold);
}

.score-bar__settings {
  margin-left: auto;
  font-size: 1.2rem;
  padding: 4px 8px;
  flex-shrink: 0;
  color: var(--text-secondary);
}

/* Main scrollable game area */
.game-scroll-container {
  flex: 1;
  overflow-y: scroll;
  scroll-snap-type: y mandatory;
  -webkit-overflow-scrolling: touch;
  scroll-behavior: smooth;
}

.game-section {
  scroll-snap-align: start;
  min-height: calc(100dvh - var(--score-bar-height));
  padding: var(--section-padding);
  display: flex;
  flex-direction: column;
  position: relative;
}

/* Section navigation dots */
.section-nav {
  position: fixed;
  right: 6px;
  top: 50%;
  transform: translateY(-50%);
  display: flex;
  flex-direction: column;
  gap: 8px;
  z-index: 40;
}

.section-nav__dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: var(--text-muted);
  transition: all var(--anim-fast);
  padding: 0;
}
.section-nav__dot--active {
  background: var(--accent-gold);
  transform: scale(1.3);
}

/* ========== SECTION 1: Market Area ========== */
.market-section {
  align-items: center;
  justify-content: center;
}

.market-area {
  position: relative;
  width: 100%;
  max-width: 380px;
  aspect-ratio: 1;
}

/* Factory displays in a circle */
.factory-ring {
  position: absolute;
  inset: 0;
}

.factory {
  position: absolute;
  width: var(--factory-size);
  height: var(--factory-size);
  border-radius: var(--factory-radius);
  background: var(--bg-surface);
  border: 2px solid rgba(255,255,255,0.08);
  display: grid;
  grid-template-columns: 1fr 1fr;
  grid-template-rows: 1fr 1fr;
  gap: 4px;
  padding: 8px;
  place-items: center;
  box-shadow: var(--shadow-sm);
  transition: border-color var(--anim-fast);
  transform: translate(-50%, -50%);
}

.factory--empty {
  opacity: 0.3;
  pointer-events: none;
}

.factory--has-selection {
  border-color: var(--accent-gold);
}

/* Center pool */
.center-pool {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: calc(var(--factory-size) * 1.3);
  height: calc(var(--factory-size) * 1.3);
  border-radius: 50%;
  background: rgba(255,255,255,0.03);
  border: 2px dashed rgba(255,255,255,0.08);
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  justify-content: center;
  gap: 3px;
  padding: 12px;
  overflow: hidden;
}

.center-pool--has-tiles {
  border-color: rgba(255,255,255,0.15);
}

.center-pool .tile {
  width: calc(var(--tile-size) * 0.75);
  height: calc(var(--tile-size) * 0.75);
}

/* Turn indicator */
.turn-indicator {
  text-align: center;
  margin-top: 12px;
  font-size: 0.85rem;
  color: var(--text-secondary);
}
.turn-indicator__name {
  color: var(--accent-gold);
  font-weight: 600;
}

/* ========== SECTION 2: Your Board ========== */
.board-section {
  justify-content: center;
}

.player-board {
  max-width: 420px;
  width: 100%;
  margin: 0 auto;
}

.board-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.board-header__name {
  font-family: 'Cinzel', serif;
  font-size: 1rem;
  color: var(--accent-gold);
}

.board-header__score {
  font-size: 1.5rem;
  font-weight: 700;
  color: var(--accent-gold);
}

/* Pattern lines + Wall container */
.board-grid {
  display: flex;
  gap: 8px;
  align-items: flex-start;
}

/* Pattern lines (left side) */
.pattern-lines {
  display: flex;
  flex-direction: column;
  gap: var(--tile-gap);
  flex-shrink: 0;
}

.pattern-line {
  display: flex;
  gap: var(--tile-gap);
  justify-content: flex-end;
  height: var(--tile-size);
  align-items: center;
  cursor: pointer;
  padding: 0 2px;
  border-radius: var(--tile-radius);
  transition: background var(--anim-fast);
}

.pattern-line--legal {
  background: rgba(201, 168, 76, 0.08);
}

.pattern-line--legal:hover {
  background: rgba(201, 168, 76, 0.15);
}

.pattern-line .tile-slot {
  width: var(--tile-size);
  height: var(--tile-size);
}

/* Arrow between pattern lines and wall */
.board-arrow {
  display: flex;
  flex-direction: column;
  justify-content: space-around;
  padding: 4px 0;
  align-self: stretch;
}

.board-arrow__icon {
  color: var(--text-muted);
  font-size: 0.7rem;
  opacity: 0.4;
}

/* Wall grid (right side) */
.wall-grid {
  display: grid;
  grid-template-columns: repeat(5, var(--tile-size));
  grid-template-rows: repeat(5, var(--tile-size));
  gap: var(--tile-gap);
}

.wall-cell {
  width: var(--tile-size);
  height: var(--tile-size);
  border-radius: var(--tile-radius);
  position: relative;
}

/* Floor line */
.floor-line {
  margin-top: 16px;
  display: flex;
  align-items: flex-end;
  gap: 4px;
}

.floor-line__label {
  font-size: 0.7rem;
  color: var(--text-muted);
  margin-right: 4px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  align-self: center;
}

.floor-slot {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2px;
}

.floor-slot__tile {
  width: calc(var(--tile-size) * 0.8);
  height: calc(var(--tile-size) * 0.8);
  border-radius: var(--tile-radius);
  border: 2px dashed rgba(255,255,255,0.08);
  background: rgba(255,255,255,0.02);
}

.floor-slot__penalty {
  font-size: 0.6rem;
  color: var(--danger);
  font-weight: 600;
}

.floor-line--legal {
  cursor: pointer;
}
.floor-line--legal .floor-slot__tile {
  border-color: var(--accent-gold);
  animation: legalPulse 1.2s ease-in-out infinite;
}

/* ========== SECTION 3: Opponent Boards ========== */
.opponents-section {
  padding-top: 16px;
}

.opponents-label {
  font-family: 'Cinzel', serif;
  font-size: 0.8rem;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.1em;
  margin-bottom: 12px;
}

.opponent-boards {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.opponent-board {
  background: var(--bg-secondary);
  border-radius: 12px;
  padding: 12px;
  border: 1px solid rgba(255,255,255,0.05);
}

.opponent-board__header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.opponent-board__name {
  font-weight: 600;
  font-size: 0.85rem;
}

.opponent-board__score {
  font-weight: 700;
  color: var(--accent-gold);
}

/* Mini wall for opponents */
.mini-wall {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: 2px;
}

.mini-wall__cell {
  aspect-ratio: 1;
  border-radius: 3px;
  background: rgba(255,255,255,0.04);
  max-width: 24px;
}

.mini-wall__cell--filled {
  opacity: 0.8;
}

/* Mini floor line */
.mini-floor {
  display: flex;
  gap: 2px;
  margin-top: 6px;
}

.mini-floor__slot {
  width: 16px;
  height: 16px;
  border-radius: 3px;
  background: rgba(255,255,255,0.04);
}
.mini-floor__slot--filled {
  background: var(--danger);
  opacity: 0.6;
}

/* ========== Game Over Overlay ========== */
.game-over-overlay {
  position: fixed;
  inset: 0;
  background: rgba(13, 27, 42, 0.95);
  z-index: 200;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 24px;
  animation: fadeIn var(--anim-slow) var(--easing-smooth);
}

.game-over__crown {
  font-size: 4rem;
  margin-bottom: 8px;
  animation: crownBounce 0.8s var(--easing-bounce);
}

.game-over__title {
  font-family: 'Cinzel', serif;
  font-size: 1.8rem;
  color: var(--accent-gold);
  margin-bottom: 4px;
}

.game-over__winner {
  font-size: 1.1rem;
  color: var(--text-primary);
  margin-bottom: 24px;
}

.game-over__scores {
  width: 100%;
  max-width: 340px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-bottom: 32px;
}

.game-over__player {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px 16px;
  background: var(--bg-surface);
  border-radius: 10px;
}

.game-over__player--winner {
  background: rgba(201, 168, 76, 0.15);
  border: 1px solid var(--accent-gold);
}

.game-over__rank {
  font-family: 'Cinzel', serif;
  font-weight: 700;
  font-size: 1.2rem;
  width: 32px;
  text-align: center;
  color: var(--accent-gold);
}

.game-over__player-name { flex: 1; font-weight: 500; }

.game-over__player-score {
  font-weight: 700;
  font-size: 1.2rem;
  color: var(--accent-gold);
}

.game-over__bonus-detail {
  font-size: 0.75rem;
  color: var(--text-secondary);
}

.game-over__actions {
  display: flex;
  gap: 12px;
}

/* Settings panel */
.settings-overlay {
  position: fixed;
  inset: 0;
  background: rgba(13, 27, 42, 0.9);
  z-index: 100;
  display: none;
  align-items: center;
  justify-content: center;
}
.settings-overlay.visible { display: flex; }

.settings-panel {
  background: var(--bg-secondary);
  border-radius: 16px;
  padding: 24px;
  width: 90%;
  max-width: 340px;
  box-shadow: var(--shadow-lg);
}

.settings-panel h3 {
  margin-bottom: 16px;
  text-align: center;
}

.setting-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 0;
  border-bottom: 1px solid rgba(255,255,255,0.05);
}

.setting-row:last-child { border-bottom: none; }

.setting-label { font-size: 0.9rem; }

/* Toggle switch */
.toggle {
  width: 48px;
  height: 26px;
  background: var(--bg-surface);
  border-radius: 13px;
  position: relative;
  cursor: pointer;
  transition: background var(--anim-fast);
}
.toggle.active { background: var(--accent-blue); }
.toggle::after {
  content: '';
  position: absolute;
  width: 22px; height: 22px;
  border-radius: 50%;
  background: white;
  top: 2px; left: 2px;
  transition: transform var(--anim-fast);
}
.toggle.active::after { transform: translateX(22px); }

@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
@keyframes crownBounce {
  0% { transform: scale(0) rotate(-20deg); }
  60% { transform: scale(1.3) rotate(5deg); }
  100% { transform: scale(1) rotate(0deg); }
}

/* === css/board-summer.css === */
/* css/board-summer.css — Summer Pavilion board overrides */
/* Loaded dynamically when Summer Pavilion variant is active */

.summer-board .board-grid { display: block; }

.star-board {
  position: relative;
  width: 100%;
  max-width: 380px;
  aspect-ratio: 1;
  margin: 0 auto;
}

.star-group {
  position: absolute;
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  align-items: center;
}

/* Star positions in hexagonal arrangement */
.star-group--center { top: 50%; left: 50%; transform: translate(-50%, -50%); }
.star-group--red    { top: 12%; left: 50%; transform: translate(-50%, 0); }
.star-group--blue   { top: 28%; left: 82%; transform: translate(-50%, 0); }
.star-group--yellow { top: 62%; left: 82%; transform: translate(-50%, 0); }
.star-group--orange { top: 78%; left: 50%; transform: translate(-50%, 0); }
.star-group--green  { top: 62%; left: 18%; transform: translate(-50%, 0); }
.star-group--purple { top: 28%; left: 18%; transform: translate(-50%, 0); }

.star-space {
  width: calc(var(--tile-size) * 0.7);
  height: calc(var(--tile-size) * 0.7);
  border-radius: var(--tile-radius);
  border: 2px solid rgba(255,255,255,0.1);
  background: rgba(255,255,255,0.03);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.6rem;
  color: var(--text-muted);
  cursor: pointer;
  transition: all var(--anim-fast);
  margin: 1px;
}

.star-space--filled {
  opacity: 1;
  cursor: default;
}

.star-space--legal {
  border-color: var(--accent-gold);
  animation: legalPulse 1.2s ease-in-out infinite;
}

/* Decoration icons */
.decoration {
  position: absolute;
  width: 20px;
  height: 20px;
  border-radius: 4px;
  background: var(--bg-surface);
  border: 1px solid rgba(255,255,255,0.1);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.5rem;
}

.decoration--complete {
  background: var(--accent-gold);
  color: var(--bg-primary);
}

/* Supply area */
.supply-area {
  display: flex;
  gap: 4px;
  flex-wrap: wrap;
  justify-content: center;
  margin-top: 12px;
  padding: 8px;
  background: var(--bg-surface);
  border-radius: 8px;
}

.supply-slot {
  width: calc(var(--tile-size) * 0.7);
  height: calc(var(--tile-size) * 0.7);
  border-radius: var(--tile-radius);
  border: 1px dashed rgba(255,255,255,0.1);
}

/* Corner storage */
.corner-storage {
  display: flex;
  gap: 4px;
  margin-top: 8px;
  justify-content: center;
}

.corner-storage__label {
  font-size: 0.7rem;
  color: var(--text-muted);
  margin-right: 4px;
  align-self: center;
}

/* Wild color indicator */
.wild-indicator {
  text-align: center;
  padding: 6px 12px;
  background: var(--bg-surface);
  border-radius: 20px;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  margin: 8px auto;
  font-size: 0.8rem;
}

.wild-indicator__color {
  width: 16px;
  height: 16px;
  border-radius: 4px;
}

.wild-indicator__label {
  color: var(--text-secondary);
}

/* === css/animations.css === */
/* css/animations.css — Keyframe animations */

@keyframes tilePick {
  0% { transform: scale(1); }
  50% { transform: scale(1.15); }
  100% { transform: scale(1); }
}

@keyframes tileSlide {
  0% { opacity: 1; }
  100% { opacity: 1; }
}

@keyframes tileFloorDrop {
  0% { transform: translateY(-20px); opacity: 0; }
  60% { transform: translateY(4px); }
  100% { transform: translateY(0); opacity: 1; }
}

@keyframes scorePop {
  0% { transform: scale(0) translateY(0); opacity: 0; }
  50% { transform: scale(1.2) translateY(-10px); opacity: 1; }
  100% { transform: scale(1) translateY(-20px); opacity: 0; }
}

@keyframes factoryRefill {
  0% { transform: scale(0) rotate(-90deg); opacity: 0; }
  100% { transform: scale(1) rotate(0deg); opacity: 1; }
}

@keyframes roundTransition {
  0% { opacity: 0; transform: scale(0.8); }
  20% { opacity: 1; transform: scale(1); }
  80% { opacity: 1; transform: scale(1); }
  100% { opacity: 0; transform: scale(1.1); }
}

@keyframes slideInUp {
  from { transform: translateY(20px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

@keyframes slideInDown {
  from { transform: translateY(-20px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

@keyframes pulseGlow {
  0%, 100% { box-shadow: 0 0 0 0 rgba(201,168,76,0); }
  50% { box-shadow: 0 0 0 8px rgba(201,168,76,0.2); }
}

@keyframes shimmer {
  0% { background-position: -200% 0; }
  100% { background-position: 200% 0; }
}

/* Round transition overlay */
.round-overlay {
  position: fixed;
  inset: 0;
  background: rgba(13, 27, 42, 0.9);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 150;
  pointer-events: none;
}

.round-overlay__text {
  font-family: 'Cinzel', serif;
  font-size: 2.5rem;
  color: var(--accent-gold);
  animation: roundTransition 1.5s var(--easing-smooth) forwards;
}

.round-overlay__sub {
  font-size: 1rem;
  color: var(--text-secondary);
  animation: roundTransition 1.5s var(--easing-smooth) 0.2s forwards;
  opacity: 0;
}

/* Score popup (floating +N) */
.score-popup {
  position: absolute;
  font-weight: 700;
  font-size: 1.1rem;
  color: var(--accent-gold);
  pointer-events: none;
  z-index: 50;
  animation: scorePop 0.8s var(--easing-smooth) forwards;
  text-shadow: 0 1px 4px rgba(0,0,0,0.5);
}

.score-popup--negative {
  color: var(--danger);
}

/* Reduced motion */
@media (prefers-reduced-motion: reduce) {
  *, *::before, *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}

/* === css/responsive.css === */
/* css/responsive.css — Breakpoint adjustments */

/* Large phones */
@media (min-width: 390px) {
  .market-area { max-width: 380px; }
}

/* Tablets */
@media (min-width: 768px) {
  .game-scroll-container {
    scroll-snap-type: none;
  }

  .game-section {
    min-height: auto;
    padding: 24px;
  }

  .market-area { max-width: 480px; }

  .opponent-boards {
    flex-direction: row;
    flex-wrap: wrap;
    gap: 16px;
  }

  .opponent-board {
    flex: 1;
    min-width: 250px;
  }
}

/* Desktop */
@media (min-width: 1024px) {
  .game-container {
    flex-direction: column;
  }

  .game-scroll-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: 1fr auto;
    gap: 16px;
    padding: 16px;
    overflow-y: auto;
  }

  .market-section {
    grid-row: 1;
    grid-column: 1;
    min-height: auto;
  }

  .board-section {
    grid-row: 1;
    grid-column: 2;
    min-height: auto;
  }

  .opponents-section {
    grid-row: 2;
    grid-column: 1 / -1;
    min-height: auto;
  }

  .section-nav { display: none; }

  .market-area { max-width: 500px; }
}

/* Very small screens */
@media (max-width: 359px) {
  :root {
    --tile-size: 36px;
    --factory-size: 80px;
  }

  .lobby__title { font-size: 2.2rem; }
  .score-bar { padding: 0 8px; }
  .score-bar__player { padding: 3px 6px; font-size: 0.7rem; }
}

/* Landscape orientation on mobile */
@media (max-height: 500px) and (orientation: landscape) {
  .game-scroll-container {
    scroll-snap-type: none;
  }

  .game-section {
    min-height: auto;
  }

  :root {
    --tile-size: 32px;
    --factory-size: 72px;
    --score-bar-height: 40px;
  }
}

  </style>
</head>
<body>
  <div id="app">
    <div class="loading-overlay" id="loading">
      <div class="loading-spinner"></div>
      <span style="color: var(--text-secondary, #aaa); font-size: 0.9rem;">Loading Azul...</span>
    </div>
  </div>
  <div id="toast-container" class="toast-container" aria-live="polite" aria-atomic="true"></div>
  <script>
// === js/config.js ===
// js/config.js — Game constants, tile definitions, wall patterns

const CLASSIC = {
  COLORS: ['blue', 'yellow', 'red', 'black', 'white'],
  TILES_PER_COLOR: 20,
  TOTAL_TILES: 100,
  FACTORIES: { 2: 5, 3: 7, 4: 9 },
  TILES_PER_FACTORY: 4,
  WALL_PATTERN: [
    ['blue','yellow','red','black','white'],
    ['white','blue','yellow','red','black'],
    ['black','white','blue','yellow','red'],
    ['red','black','white','blue','yellow'],
    ['yellow','red','black','white','blue'],
  ],
  FLOOR_PENALTIES: [-1, -1, -2, -2, -2, -3, -3],
  BONUS_ROW: 2,
  BONUS_COLUMN: 7,
  BONUS_COLOR_SET: 10,
  MIN_SCORE: 0,
  PATTERN_LINE_SIZES: [1, 2, 3, 4, 5],
};

const SUMMER = {
  COLORS: ['purple', 'green', 'orange', 'yellow', 'blue', 'red'],
  TILES_PER_COLOR: 22,
  TOTAL_TILES: 132,
  ROUNDS: 6,
  FACTORIES: { 2: 5, 3: 7, 4: 9 },
  TILES_PER_FACTORY: 4,
  WILD_SEQUENCE: ['purple', 'green', 'orange', 'yellow', 'blue', 'red'],
  STARTING_SCORE: 5,
  MIN_SCORE: 1,
  CORNER_STORAGE: 4,
  SUPPLY_SPACES: 10,
  STAR_BONUSES: { center: 12, red: 14, blue: 15, yellow: 16, orange: 17, green: 18, purple: 20 },
  NUMBER_BONUSES: { 1: 4, 2: 8, 3: 12, 4: 16, 5: 0, 6: 0 },
};

const ASSETS = {
  TILE_SETS: {
    classic: {
      blue: 'assets/tiles/classic/blue.png',
      yellow: 'assets/tiles/classic/yellow.png',
      red: 'assets/tiles/classic/red.png',
      black: 'assets/tiles/classic/black.png',
      white: 'assets/tiles/classic/white.png',
      firstPlayer: 'assets/tiles/classic/first-player.png',
    },
    summer: {
      purple: 'assets/tiles/summer/purple.png',
      green: 'assets/tiles/summer/green.png',
      orange: 'assets/tiles/summer/orange.png',
      yellow: 'assets/tiles/summer/yellow.png',
      blue: 'assets/tiles/summer/blue.png',
      red: 'assets/tiles/summer/red.png',
      wildGlow: 'assets/tiles/summer/wild-glow.png',
    }
  },
  AUDIO: {
    tilePick: 'assets/audio/tile-pick.mp3',
    tilePlace: 'assets/audio/tile-place.mp3',
    tileWall: 'assets/audio/tile-wall.mp3',
    tileBreak: 'assets/audio/tile-break.mp3',
    scoreTick: 'assets/audio/score-tick.mp3',
    scoreBonus: 'assets/audio/score-bonus.mp3',
    roundEnd: 'assets/audio/round-end.mp3',
    gameOver: 'assets/audio/game-over.mp3',
    turnAlert: 'assets/audio/turn-alert.mp3',
    playerJoin: 'assets/audio/player-join.mp3',
    error: 'assets/audio/error.mp3',
  },
};

// Deep clone utility
function deepCopy(obj) {
  return JSON.parse(JSON.stringify(obj));
}

// Generate unique IDs
let _idCounter = 0;
function genId() {
  return `id_${Date.now()}_${++_idCounter}`;
}

// === js/engine/TileBag.js ===
// js/engine/TileBag.js — Bag draw, refill from discard

class TileBag {
  constructor(colors, tilesPerColor) {
    this.tiles = [];
    for (const color of colors) {
      for (let i = 0; i < tilesPerColor; i++) {
        this.tiles.push(color);
      }
    }
    this.shuffle();
  }

  static fromArray(tiles) {
    const bag = new TileBag([], 0);
    bag.tiles = [...tiles];
    return bag;
  }

  shuffle() {
    // Fisher-Yates shuffle
    for (let i = this.tiles.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [this.tiles[i], this.tiles[j]] = [this.tiles[j], this.tiles[i]];
    }
  }

  draw(n, discardPile = []) {
    const drawn = [];
    for (let i = 0; i < n; i++) {
      if (this.tiles.length === 0) {
        if (discardPile.length === 0) break; // Both empty
        this.refillFromDiscard(discardPile);
      }
      if (this.tiles.length > 0) {
        drawn.push(this.tiles.pop());
      }
    }
    return drawn;
  }

  refillFromDiscard(discardPile) {
    this.tiles = [...discardPile];
    discardPile.length = 0; // Empty the discard
    this.shuffle();
  }

  remaining() {
    return this.tiles.length;
  }

  isEmpty() {
    return this.tiles.length === 0;
  }

  toArray() {
    return [...this.tiles];
  }
}

// === js/engine/FloorLine.js ===
// js/engine/FloorLine.js — Floor penalty calculation (Classic)


class FloorLine {
  static calculatePenalty(floorLine) {
    let penalty = 0;
    for (let i = 0; i < Math.min(floorLine.length, 7); i++) {
      penalty += CLASSIC.FLOOR_PENALTIES[i];
    }
    return penalty; // Always negative or zero
  }

  static addToFloor(floorLine, tiles, hasFirstPlayer = false) {
    const newFloor = [...floorLine];
    if (hasFirstPlayer) {
      newFloor.push('first-player');
    }
    newFloor.push(...tiles);

    // Tiles beyond position 6 go to discard with no additional penalty
    const kept = newFloor.slice(0, 7);
    const excess = newFloor.slice(7);

    // Filter out first-player marker from excess discard (it's not a real tile)
    const discardExcess = excess.filter(t => t !== 'first-player');

    return { newFloor: kept, discardExcess };
  }

  static getDiscardTiles(floorLine) {
    // All tiles on floor go to discard at end of round (except first-player marker)
    return floorLine.filter(t => t !== 'first-player');
  }

  static getPenaltyAtPosition(position) {
    if (position < 0 || position >= 7) return 0;
    return CLASSIC.FLOOR_PENALTIES[position];
  }
}

// === js/engine/Wall.js ===
// js/engine/Wall.js — Wall placement + adjacency scoring (Classic)


class Wall {
  static getColumnForColor(row, color) {
    return CLASSIC.WALL_PATTERN[row].indexOf(color);
  }

  static getColorForPosition(row, col) {
    return CLASSIC.WALL_PATTERN[row][col];
  }

  static canPlaceColor(wall, row, color) {
    const col = Wall.getColumnForColor(row, color);
    if (col === -1) return false;
    return wall[row][col] === null;
  }

  static placeTile(wall, row, color) {
    const col = Wall.getColumnForColor(row, color);
    if (col === -1 || wall[row][col] !== null) {
      return null; // Invalid placement
    }

    const newWall = wall.map(r => [...r]);
    newWall[row][col] = color;
    const score = Wall.scoreAdjacency(newWall, row, col);

    return { newWall, col, score };
  }

  static scoreAdjacency(wall, row, col) {
    let horizontal = 1;
    let vertical = 1;

    // Count left
    for (let c = col - 1; c >= 0 && wall[row][c] !== null; c--) horizontal++;
    // Count right
    for (let c = col + 1; c < 5 && wall[row][c] !== null; c++) horizontal++;
    // Count up
    for (let r = row - 1; r >= 0 && wall[r][col] !== null; r--) vertical++;
    // Count down
    for (let r = row + 1; r < 5 && wall[r][col] !== null; r++) vertical++;

    if (horizontal === 1 && vertical === 1) return 1; // isolated tile
    let score = 0;
    if (horizontal > 1) score += horizontal;
    if (vertical > 1) score += vertical;
    return score;
  }

  static getEndGameBonuses(wall) {
    let bonus = 0;
    const details = { rows: 0, columns: 0, colors: 0 };

    // Complete rows: +2 each
    for (let r = 0; r < 5; r++) {
      if (wall[r].every(cell => cell !== null)) {
        bonus += CLASSIC.BONUS_ROW;
        details.rows++;
      }
    }

    // Complete columns: +7 each
    for (let c = 0; c < 5; c++) {
      if (wall.every(row => row[c] !== null)) {
        bonus += CLASSIC.BONUS_COLUMN;
        details.columns++;
      }
    }

    // Complete color sets: +10 each
    for (const color of CLASSIC.COLORS) {
      let count = 0;
      for (let r = 0; r < 5; r++) {
        for (let c = 0; c < 5; c++) {
          if (wall[r][c] === color) count++;
        }
      }
      if (count === 5) {
        bonus += CLASSIC.BONUS_COLOR_SET;
        details.colors++;
      }
    }

    return { bonus, details };
  }

  static hasCompleteRow(wall) {
    return wall.some(row => row.every(cell => cell !== null));
  }

  static countCompleteRows(wall) {
    return wall.filter(row => row.every(cell => cell !== null)).length;
  }

  static createEmptyWall() {
    return Array.from({ length: 5 }, () => Array(5).fill(null));
  }
}

// === js/engine/PatternLine.js ===
// js/engine/PatternLine.js — Pattern line placement + overflow (Classic)


class PatternLine {
  static canPlace(patternLine, color, rowIndex, wall) {
    // If line has tiles of different color, can't place
    if (patternLine.length > 0 && patternLine[0] !== color) {
      return false;
    }
    // If wall already has this color in corresponding row
    if (!Wall.canPlaceColor(wall, rowIndex, color)) {
      return false;
    }
    // If line is full
    const maxSize = rowIndex + 1;
    if (patternLine.length >= maxSize) {
      return false;
    }
    return true;
  }

  static place(patternLine, tiles, color, rowIndex) {
    const maxSize = rowIndex + 1;
    const currentCount = patternLine.length;
    const available = maxSize - currentCount;
    const toPlace = Math.min(tiles.length, available);
    const overflow = tiles.length - toPlace;

    const newLine = [...patternLine];
    for (let i = 0; i < toPlace; i++) {
      newLine.push(color);
    }

    return {
      newLine,
      placed: toPlace,
      overflowCount: overflow,
      overflowTiles: Array(overflow).fill(color),
    };
  }

  static isComplete(patternLine, rowIndex) {
    return patternLine.length === rowIndex + 1;
  }

  static tileToWall(patternLine) {
    if (patternLine.length === 0) return null;
    const color = patternLine[0];
    // One tile goes to wall, rest go to discard
    const discardTiles = Array(patternLine.length - 1).fill(color);
    return { color, discardTiles };
  }

  static createEmptyPatternLines() {
    return [[], [], [], [], []];
  }

  static getAnyLegalRow(color, patternLines, wall) {
    for (let row = 0; row < 5; row++) {
      if (PatternLine.canPlace(patternLines[row], color, row, wall)) {
        return row;
      }
    }
    return -1; // No legal row — must go to floor
  }

  static hasAnyLegalRow(color, patternLines, wall) {
    return PatternLine.getAnyLegalRow(color, patternLines, wall) !== -1;
  }
}

// === js/engine/FactoryDisplay.js ===
// js/engine/FactoryDisplay.js — Factory setup, tile picking logic

class FactoryDisplay {
  static getFactoryCount(playerCount, config) {
    return config.FACTORIES[playerCount] || 5;
  }

  static createFactories(count) {
    return Array.from({ length: count }, () => []);
  }

  static fillFactories(factories, bag, discard, tilesPerFactory = 4) {
    const newFactories = factories.map(() => []);
    for (let i = 0; i < newFactories.length; i++) {
      const drawn = bag.draw(tilesPerFactory, discard);
      newFactories[i] = drawn;
    }
    return newFactories;
  }

  static pickFromFactory(factories, factoryIndex, color) {
    const factory = [...factories[factoryIndex]];
    const taken = factory.filter(t => t === color);
    const remaining = factory.filter(t => t !== color);

    if (taken.length === 0) {
      return null; // Invalid pick
    }

    const newFactories = factories.map((f, i) =>
      i === factoryIndex ? [] : [...f]
    );

    return { taken, remaining, newFactories };
  }

  static pickFromCenter(center, color, centerHasFirstPlayer) {
    const taken = center.filter(t => t === color);
    const newCenter = center.filter(t => t !== color);

    if (taken.length === 0) {
      return null; // Invalid pick
    }

    const tookFirstPlayer = centerHasFirstPlayer;

    return {
      taken,
      newCenter,
      tookFirstPlayer,
      newCenterHasFirstPlayer: tookFirstPlayer ? false : centerHasFirstPlayer,
    };
  }

  static allEmpty(factories, center) {
    return factories.every(f => f.length === 0) && center.length === 0;
  }

  static getAvailableColors(factories, center) {
    const colors = new Set();
    for (const factory of factories) {
      for (const tile of factory) colors.add(tile);
    }
    for (const tile of center) colors.add(tile);
    return [...colors];
  }

  static getFactoryColors(factory) {
    const colors = new Set(factory);
    return [...colors];
  }

  // Summer Pavilion: pick with wild tile logic
  static pickFromFactorySummer(factories, factoryIndex, color, wildColor) {
    const factory = [...factories[factoryIndex]];

    if (color === wildColor) {
      return null; // Cannot select wild color as choice
    }

    const taken = factory.filter(t => t === color);
    if (taken.length === 0) return null;

    // Take at most 1 wild tile from this factory
    let wildTaken = [];
    const remainingAfterColor = factory.filter(t => t !== color);
    const wildIndex = remainingAfterColor.indexOf(wildColor);
    if (wildIndex !== -1) {
      wildTaken = [wildColor];
      remainingAfterColor.splice(wildIndex, 1);
    }

    const newFactories = factories.map((f, i) =>
      i === factoryIndex ? [] : [...f]
    );

    return {
      taken: [...taken, ...wildTaken],
      remaining: remainingAfterColor,
      newFactories,
    };
  }

  static pickFromCenterSummer(center, color, wildColor, centerHasFirstPlayer) {
    if (color === wildColor) {
      // Special case: only wild tiles in center, can take exactly 1
      const onlyWild = center.every(t => t === wildColor);
      if (onlyWild && center.length > 0) {
        const newCenter = center.slice(1);
        return {
          taken: [wildColor],
          newCenter,
          tookFirstPlayer: centerHasFirstPlayer,
          newCenterHasFirstPlayer: false,
        };
      }
      return null;
    }

    const taken = center.filter(t => t === color);
    if (taken.length === 0) return null;

    let newCenter = center.filter(t => t !== color);

    // Take at most 1 wild from center
    let wildTaken = [];
    const wildIdx = newCenter.indexOf(wildColor);
    if (wildIdx !== -1) {
      wildTaken = [wildColor];
      newCenter = [...newCenter];
      newCenter.splice(wildIdx, 1);
    }

    const tookFirstPlayer = centerHasFirstPlayer;

    return {
      taken: [...taken, ...wildTaken],
      newCenter,
      tookFirstPlayer,
      newCenterHasFirstPlayer: tookFirstPlayer ? false : centerHasFirstPlayer,
    };
  }
}

// === js/engine/StarBoard.js ===
// js/engine/StarBoard.js — Star placement + decoration bonuses (Summer Pavilion)



// Decoration adjacency map
const DECORATION_MAP = [
  // Pillars (4 adjacent spaces, 1 bonus tile)
  { type: 'pillar', id: 'p1', surroundedBy: [
    {star:'red', pos:1}, {star:'blue', pos:1}, {star:'center', pos:1}, {star:'center', pos:6}
  ], bonusTiles: 1 },
  { type: 'pillar', id: 'p2', surroundedBy: [
    {star:'blue', pos:1}, {star:'yellow', pos:1}, {star:'center', pos:1}, {star:'center', pos:2}
  ], bonusTiles: 1 },
  { type: 'pillar', id: 'p3', surroundedBy: [
    {star:'yellow', pos:1}, {star:'orange', pos:1}, {star:'center', pos:2}, {star:'center', pos:3}
  ], bonusTiles: 1 },
  { type: 'pillar', id: 'p4', surroundedBy: [
    {star:'orange', pos:1}, {star:'green', pos:1}, {star:'center', pos:3}, {star:'center', pos:4}
  ], bonusTiles: 1 },
  { type: 'pillar', id: 'p5', surroundedBy: [
    {star:'green', pos:1}, {star:'purple', pos:1}, {star:'center', pos:4}, {star:'center', pos:5}
  ], bonusTiles: 1 },
  { type: 'pillar', id: 'p6', surroundedBy: [
    {star:'purple', pos:1}, {star:'red', pos:1}, {star:'center', pos:5}, {star:'center', pos:6}
  ], bonusTiles: 1 },

  // Statues (4 adjacent spaces, 2 bonus tiles)
  { type: 'statue', id: 's1', surroundedBy: [
    {star:'red', pos:2}, {star:'red', pos:3}, {star:'blue', pos:5}, {star:'blue', pos:6}
  ], bonusTiles: 2 },
  { type: 'statue', id: 's2', surroundedBy: [
    {star:'blue', pos:2}, {star:'blue', pos:3}, {star:'yellow', pos:5}, {star:'yellow', pos:6}
  ], bonusTiles: 2 },
  { type: 'statue', id: 's3', surroundedBy: [
    {star:'yellow', pos:2}, {star:'yellow', pos:3}, {star:'orange', pos:5}, {star:'orange', pos:6}
  ], bonusTiles: 2 },
  { type: 'statue', id: 's4', surroundedBy: [
    {star:'orange', pos:2}, {star:'orange', pos:3}, {star:'green', pos:5}, {star:'green', pos:6}
  ], bonusTiles: 2 },
  { type: 'statue', id: 's5', surroundedBy: [
    {star:'green', pos:2}, {star:'green', pos:3}, {star:'purple', pos:5}, {star:'purple', pos:6}
  ], bonusTiles: 2 },
  { type: 'statue', id: 's6', surroundedBy: [
    {star:'purple', pos:2}, {star:'purple', pos:3}, {star:'red', pos:5}, {star:'red', pos:6}
  ], bonusTiles: 2 },

  // Windows (2 adjacent spaces, 3 bonus tiles)
  { type: 'window', id: 'w1', surroundedBy: [
    {star:'red', pos:5}, {star:'red', pos:6}
  ], bonusTiles: 3 },
  { type: 'window', id: 'w2', surroundedBy: [
    {star:'blue', pos:5}, {star:'blue', pos:6}
  ], bonusTiles: 3 },
  { type: 'window', id: 'w3', surroundedBy: [
    {star:'yellow', pos:5}, {star:'yellow', pos:6}
  ], bonusTiles: 3 },
  { type: 'window', id: 'w4', surroundedBy: [
    {star:'orange', pos:5}, {star:'orange', pos:6}
  ], bonusTiles: 3 },
  { type: 'window', id: 'w5', surroundedBy: [
    {star:'green', pos:5}, {star:'green', pos:6}
  ], bonusTiles: 3 },
  { type: 'window', id: 'w6', surroundedBy: [
    {star:'purple', pos:5}, {star:'purple', pos:6}
  ], bonusTiles: 3 },
];

class StarBoard {
  static createEmpty() {
    const board = {};
    const stars = ['red', 'blue', 'yellow', 'orange', 'green', 'purple', 'center'];
    for (const star of stars) {
      board[star] = {}; // positions 1-6, each null or color string
      for (let i = 1; i <= 6; i++) {
        board[star][i] = null;
      }
    }
    return board;
  }

  static canPlace(starBoard, star, position, tilesInHand, wildColor) {
    // Position already filled
    if (starBoard[star][position] !== null) return false;

    // Cost = position number
    const cost = position;
    if (tilesInHand.length < cost) return false;

    // Determine the star's required color
    const starColor = star === 'center' ? null : star;

    if (starColor) {
      // Must have at least 1 non-wild tile of the star's color
      const nonWild = tilesInHand.filter(t => t === starColor);
      if (nonWild.length === 0) return false;
    } else {
      // Center star: the tile must be a color not already on center star
      const usedColors = new Set();
      for (let i = 1; i <= 6; i++) {
        if (starBoard.center[i]) usedColors.add(starBoard.center[i]);
      }
      // Need at least 1 non-wild tile of a color not yet on center
      const eligible = tilesInHand.filter(t => t !== wildColor && !usedColors.has(t));
      if (eligible.length === 0) return false;
    }

    return true;
  }

  static place(starBoard, star, position, color, tilesUsed, wildTilesUsed) {
    const newBoard = deepCopy(starBoard);
    newBoard[star][position] = color;

    // Score: 1 + contiguous adjacent filled in same star
    const score = StarBoard.scoreContiguous(newBoard, star, position);

    // Tiles used: position N costs N tiles. 1 stays on board, rest discarded
    const discardedTiles = tilesUsed + wildTilesUsed - 1;

    // Check decoration bonuses
    const decorationBonuses = StarBoard.checkDecorations(newBoard, star, position);

    return {
      newBoard,
      score,
      discardedTiles,
      decorationBonuses,
    };
  }

  static scoreContiguous(board, star, position) {
    let score = 1;
    const starData = board[star];

    // Check clockwise
    let pos = (position % 6) + 1;
    while (pos !== position && starData[pos] !== null) {
      score++;
      pos = (pos % 6) + 1;
    }

    // Check counter-clockwise
    pos = ((position - 2 + 6) % 6) + 1;
    while (pos !== position && starData[pos] !== null) {
      score++;
      pos = ((pos - 2 + 6) % 6) + 1;
    }

    return score;
  }

  static checkDecorations(board, star, position) {
    const bonuses = [];
    for (const deco of DECORATION_MAP) {
      // Check if this placement is adjacent to this decoration
      const isAdjacent = deco.surroundedBy.some(
        s => s.star === star && s.pos === position
      );
      if (!isAdjacent) continue;

      // Check if all surrounding spaces are now filled
      const allFilled = deco.surroundedBy.every(
        s => board[s.star][s.pos] !== null
      );
      if (allFilled) {
        bonuses.push({ type: deco.type, id: deco.id, bonusTiles: deco.bonusTiles });
      }
    }
    return bonuses;
  }

  static getEndGameBonuses(board) {
    let total = 0;
    const starBonuses = {};
    const numberBonuses = {};

    // Star completion bonuses
    const stars = ['red', 'blue', 'yellow', 'orange', 'green', 'purple', 'center'];
    for (const star of stars) {
      const allFilled = Object.values(board[star]).every(v => v !== null);
      if (allFilled) {
        const bonus = SUMMER.STAR_BONUSES[star] || 0;
        starBonuses[star] = bonus;
        total += bonus;
      }
    }

    // Number coverage bonuses (all 7 stars have position N filled)
    for (let n = 1; n <= 6; n++) {
      const allHaveN = stars.every(star => board[star][n] !== null);
      if (allHaveN) {
        const bonus = SUMMER.NUMBER_BONUSES[n] || 0;
        numberBonuses[n] = bonus;
        total += bonus;
      }
    }

    return { starBonuses, numberBonuses, total };
  }
}

// === js/engine/ScoringEngine.js ===
// js/engine/ScoringEngine.js — Unified scoring






class ScoringEngine {
  /**
   * Process wall-tiling for a single player (Classic variant).
   * Rows are processed TOP to BOTTOM — order matters for adjacency!
   */
  static wallTilingPhase(playerState) {
    const events = [];
    const newWall = deepCopy(playerState.wall);
    const newPatternLines = deepCopy(playerState.patternLines);
    let scoreGained = 0;
    const discardTiles = [];

    // Process rows top to bottom
    for (let row = 0; row < 5; row++) {
      if (PatternLine.isComplete(playerState.patternLines[row], row)) {
        const result = PatternLine.tileToWall(playerState.patternLines[row]);
        if (!result) continue;

        const { color, discardTiles: rowDiscard } = result;
        const col = Wall.getColumnForColor(row, color);

        newWall[row][col] = color;
        const tileScore = Wall.scoreAdjacency(newWall, row, col);
        scoreGained += tileScore;

        events.push({
          type: 'TILE_SCORED',
          row,
          col,
          color,
          points: tileScore,
        });

        discardTiles.push(...rowDiscard);
        newPatternLines[row] = []; // Clear pattern line
      }
    }

    // Floor penalty
    const floorPenalty = FloorLine.calculatePenalty(playerState.floorLine);
    if (floorPenalty < 0) {
      events.push({
        type: 'FLOOR_PENALTY',
        penalty: floorPenalty,
      });
    }

    scoreGained += floorPenalty;

    // Floor tiles go to discard
    const floorDiscard = FloorLine.getDiscardTiles(playerState.floorLine);
    discardTiles.push(...floorDiscard);

    const newScore = Math.max(CLASSIC.MIN_SCORE, playerState.score + scoreGained);

    return {
      newWall,
      newPatternLines,
      newScore,
      newFloorLine: [],
      discardTiles,
      events,
      scoreGained,
    };
  }

  /**
   * Calculate end-game bonuses for a player (Classic variant).
   */
  static calculateEndGameBonuses(wall) {
    return Wall.getEndGameBonuses(wall);
  }

  /**
   * Summer Pavilion: score a star placement.
   * Score = 1 + number of contiguous adjacent filled spaces in the same star.
   */
  static scoreStarPlacement(starBoard, starName, position) {
    const star = starBoard[starName];
    if (!star) return 1;

    // Count contiguous filled adjacent spaces
    let score = 1;
    // Check positions ±1 (wrapping for positions 1-6)
    const maxPos = 6;

    // Count clockwise
    let pos = position % maxPos + 1;
    while (pos !== position && star[pos]) {
      score++;
      pos = pos % maxPos + 1;
    }

    // Count counter-clockwise
    pos = ((position - 2 + maxPos) % maxPos) + 1;
    while (pos !== position && star[pos]) {
      score++;
      pos = ((pos - 2 + maxPos) % maxPos) + 1;
    }

    return score;
  }
}

// === js/engine/GameRules.js ===
// js/engine/GameRules.js — Validation: legal moves, blocked colors




class GameRules {
  /**
   * Get all legal moves for the current player (Classic variant).
   * Returns array of { source, factoryIndex?, color, targetRow }
   * targetRow: 0-4 for pattern lines, 'floor' for voluntary floor dump
   */
  static getLegalMoves(state) {
    const player = state.players[state.currentPlayerIndex];
    const moves = [];

    // Moves from factories
    for (let fi = 0; fi < state.factories.length; fi++) {
      const factory = state.factories[fi];
      if (factory.length === 0) continue;

      const colors = new Set(factory);
      for (const color of colors) {
        // Check each pattern line
        for (let row = 0; row < 5; row++) {
          if (PatternLine.canPlace(player.patternLines[row], color, row, player.wall)) {
            moves.push({
              source: 'factory',
              factoryIndex: fi,
              color,
              targetRow: row,
            });
          }
        }
        // Can always send to floor voluntarily
        moves.push({
          source: 'factory',
          factoryIndex: fi,
          color,
          targetRow: 'floor',
        });
      }
    }

    // Moves from center
    if (state.center.length > 0) {
      const colors = new Set(state.center);
      for (const color of colors) {
        for (let row = 0; row < 5; row++) {
          if (PatternLine.canPlace(player.patternLines[row], color, row, player.wall)) {
            moves.push({
              source: 'center',
              color,
              targetRow: row,
            });
          }
        }
        moves.push({
          source: 'center',
          color,
          targetRow: 'floor',
        });
      }
    }

    return moves;
  }

  /**
   * Validate a specific move.
   */
  static validateMove(state, action) {
    if (state.phase !== 'factory-offer') {
      return { valid: false, error: 'Not in factory offer phase' };
    }

    const player = state.players[state.currentPlayerIndex];

    if (action.source === 'factory') {
      const factory = state.factories[action.factoryIndex];
      if (!factory || factory.length === 0) {
        return { valid: false, error: 'Factory is empty' };
      }
      if (!factory.includes(action.color)) {
        return { valid: false, error: 'Color not in factory' };
      }
    } else if (action.source === 'center') {
      if (!state.center.includes(action.color)) {
        return { valid: false, error: 'Color not in center' };
      }
    } else {
      return { valid: false, error: 'Invalid source' };
    }

    if (action.targetRow !== 'floor') {
      const row = action.targetRow;
      if (row < 0 || row > 4) {
        return { valid: false, error: 'Invalid target row' };
      }
      if (!PatternLine.canPlace(player.patternLines[row], action.color, row, player.wall)) {
        return { valid: false, error: 'Cannot place this color on that row' };
      }
    }

    return { valid: true };
  }

  /**
   * Check if the factory offer phase is over.
   */
  static isRoundOver(state) {
    return FactoryDisplay.allEmpty(state.factories, state.center);
  }

  /**
   * Check if the game is over (Classic: any player has complete wall row).
   */
  static isGameOver(state) {
    if (state.variant !== 'classic') return false;
    return state.players.some(p => Wall.hasCompleteRow(p.wall));
  }

  /**
   * Determine winner. Returns { winners, tiebreaker }.
   */
  static determineWinner(state) {
    const scores = state.players.map((p, i) => ({
      index: i,
      score: p.score,
      completeRows: Wall.countCompleteRows(p.wall),
      name: p.name,
    }));

    scores.sort((a, b) => {
      if (b.score !== a.score) return b.score - a.score;
      return b.completeRows - a.completeRows; // tiebreaker
    });

    const topScore = scores[0].score;
    const topRows = scores[0].completeRows;
    const winners = scores.filter(s => s.score === topScore && s.completeRows === topRows);

    return {
      winners: winners.map(w => w.index),
      rankings: scores,
      isTie: winners.length > 1,
    };
  }
}

// === js/engine/EndGameDetector.js ===
// js/engine/EndGameDetector.js — Trigger conditions + final scoring





class EndGameDetector {
  /**
   * Classic: check if game should end after wall-tiling.
   * Trigger: any player has at least one complete horizontal row.
   */
  static shouldEndClassic(state) {
    return state.players.some(p => Wall.hasCompleteRow(p.wall));
  }

  /**
   * Summer Pavilion: game ends after round 6.
   */
  static shouldEndSummer(state) {
    return state.round > SUMMER.ROUNDS;
  }

  /**
   * Apply end-game bonuses to all players (Classic).
   */
  static applyClassicEndGame(state) {
    const newState = deepCopy(state);
    const allEvents = [];

    for (let i = 0; i < newState.players.length; i++) {
      const player = newState.players[i];
      const { bonus, details } = ScoringEngine.calculateEndGameBonuses(player.wall);

      player.score += bonus;
      player.endGameBonus = bonus;
      player.endGameDetails = details;

      allEvents.push({
        type: 'END_GAME_BONUS',
        playerIndex: i,
        bonus,
        details,
      });
    }

    newState.phase = 'game-over';
    return { newState, events: allEvents };
  }

  /**
   * Apply end-game bonuses to all players (Summer Pavilion).
   */
  static applySummerEndGame(state) {
    const newState = deepCopy(state);
    const allEvents = [];

    for (let i = 0; i < newState.players.length; i++) {
      const player = newState.players[i];

      // Discard excess tiles beyond corner storage
      if (player.handTiles && player.handTiles.length > SUMMER.CORNER_STORAGE) {
        const excess = player.handTiles.length - SUMMER.CORNER_STORAGE;
        player.score = Math.max(SUMMER.MIN_SCORE, player.score - excess);
        player.handTiles = player.handTiles.slice(0, SUMMER.CORNER_STORAGE);
      }

      // Star and number bonuses
      const { starBonuses, numberBonuses, total } = StarBoard.getEndGameBonuses(player.starBoard);
      player.score += total;
      player.endGameBonus = total;
      player.endGameDetails = { starBonuses, numberBonuses };

      allEvents.push({
        type: 'END_GAME_BONUS',
        playerIndex: i,
        bonus: total,
        details: { starBonuses, numberBonuses },
      });
    }

    newState.phase = 'game-over';
    return { newState, events: allEvents };
  }
}

// === js/engine/TurnManager.js ===
// js/engine/TurnManager.js — Turn order, phase transitions, round lifecycle






class TurnManager {
  /**
   * Advance to the next player.
   */
  static nextPlayer(state) {
    const next = (state.currentPlayerIndex + 1) % state.players.length;
    return next;
  }

  /**
   * Process the wall-tiling phase for all players (Classic).
   * Returns new state + events array.
   */
  static processWallTiling(state) {
    const newState = deepCopy(state);
    const allEvents = [];

    for (let i = 0; i < newState.players.length; i++) {
      const result = ScoringEngine.wallTilingPhase(newState.players[i]);

      newState.players[i].wall = result.newWall;
      newState.players[i].patternLines = result.newPatternLines;
      newState.players[i].score = result.newScore;
      newState.players[i].floorLine = result.newFloorLine;
      newState.discard.push(...result.discardTiles);

      allEvents.push({
        type: 'PLAYER_WALL_TILING',
        playerIndex: i,
        events: result.events,
        scoreGained: result.scoreGained,
        newScore: result.newScore,
      });
    }

    return { newState, events: allEvents };
  }

  /**
   * Process round end: check game over, set up next round.
   */
  static processRoundEnd(state) {
    // First, do wall tiling
    const { newState, events } = TurnManager.processWallTiling(state);
    const allEvents = [...events];

    // Check game over
    if (EndGameDetector.shouldEndClassic(newState)) {
      const endResult = EndGameDetector.applyClassicEndGame(newState);
      allEvents.push(...endResult.events);
      return {
        newState: endResult.newState,
        events: allEvents,
        gameOver: true,
      };
    }

    // Set up next round
    newState.round++;

    // Find who has first player marker
    let firstPlayerIdx = 0;
    for (let i = 0; i < newState.players.length; i++) {
      if (newState.players[i].hasFirstPlayer) {
        firstPlayerIdx = i;
        newState.players[i].hasFirstPlayer = false;
        break;
      }
    }
    newState.currentPlayerIndex = firstPlayerIdx;
    newState.centerHasFirstPlayer = true;
    newState.center = [];

    // Refill factories
    const bag = TileBag.fromArray(newState.bag);
    const factoryCount = FactoryDisplay.getFactoryCount(
      newState.players.length, CLASSIC
    );
    newState.factories = FactoryDisplay.fillFactories(
      FactoryDisplay.createFactories(factoryCount),
      bag,
      newState.discard,
      CLASSIC.TILES_PER_FACTORY
    );
    newState.bag = bag.toArray();

    newState.phase = 'factory-offer';

    allEvents.push({
      type: 'ROUND_START',
      round: newState.round,
    });

    return {
      newState,
      events: allEvents,
      gameOver: false,
    };
  }
}

// === js/engine/GameState.js ===
// js/engine/GameState.js — Immutable state object + reducer










class GameState {
  /**
   * Create a new game state.
   */
  static create(options) {
    const {
      variant = 'classic',
      players = [
        { name: 'Player 1', type: 'human' },
        { name: 'Player 2', type: 'ai-easy' },
      ],
    } = options;

    const config = variant === 'summer' ? SUMMER : CLASSIC;
    const bag = new TileBag(config.COLORS, config.TILES_PER_COLOR);
    const factoryCount = FactoryDisplay.getFactoryCount(players.length, config);

    const discard = [];
    const factories = FactoryDisplay.fillFactories(
      FactoryDisplay.createFactories(factoryCount),
      bag,
      discard,
      config.TILES_PER_FACTORY
    );

    const state = {
      variant,
      players: players.map((p, i) => ({
        id: `p${i + 1}`,
        name: p.name,
        type: p.type,
        score: variant === 'summer' ? SUMMER.STARTING_SCORE : 0,
        // Classic fields
        patternLines: PatternLine.createEmptyPatternLines(),
        wall: Wall.createEmptyWall(),
        floorLine: [],
        hasFirstPlayer: i === 0,
        // Summer fields
        starBoard: variant === 'summer' ? StarBoard.createEmpty() : null,
        handTiles: variant === 'summer' ? [] : null,
        hasPassed: false,
      })),
      currentPlayerIndex: 0,
      round: 1,
      phase: 'factory-offer',
      factories,
      center: [],
      centerHasFirstPlayer: true,
      bag: bag.toArray(),
      discard,
      turnHistory: [],
      // Summer-specific
      wildColor: variant === 'summer' ? SUMMER.WILD_SEQUENCE[0] : null,
    };

    return state;
  }

  /**
   * Apply an action to the state. Returns { newState, events }.
   * This is a pure function.
   */
  static applyAction(state, action) {
    if (state.variant === 'classic') {
      return GameState.applyClassicAction(state, action);
    }
    return GameState.applySummerAction(state, action);
  }

  /**
   * Classic variant action handler.
   */
  static applyClassicAction(state, action) {
    // Validate
    const validation = GameRules.validateMove(state, action);
    if (!validation.valid) {
      return { newState: state, events: [{ type: 'INVALID_MOVE', error: validation.error }] };
    }

    const newState = deepCopy(state);
    const events = [];
    const player = newState.players[newState.currentPlayerIndex];

    // 1. Pick tiles
    let taken, remaining;

    if (action.source === 'factory') {
      const pickResult = FactoryDisplay.pickFromFactory(
        newState.factories, action.factoryIndex, action.color
      );
      taken = pickResult.taken;
      remaining = pickResult.remaining;
      newState.factories = pickResult.newFactories;
      // Push remaining to center
      newState.center.push(...remaining);

      events.push({
        type: 'TILES_PICKED',
        source: 'factory',
        factoryIndex: action.factoryIndex,
        color: action.color,
        count: taken.length,
        remaining: remaining.length,
      });
    } else {
      const pickResult = FactoryDisplay.pickFromCenter(
        newState.center, action.color, newState.centerHasFirstPlayer
      );
      taken = pickResult.taken;
      newState.center = pickResult.newCenter;

      if (pickResult.tookFirstPlayer) {
        player.hasFirstPlayer = true;
        newState.centerHasFirstPlayer = false;

        events.push({
          type: 'FIRST_PLAYER_TAKEN',
          playerIndex: newState.currentPlayerIndex,
        });
      }

      events.push({
        type: 'TILES_PICKED',
        source: 'center',
        color: action.color,
        count: taken.length,
        tookFirstPlayer: pickResult.tookFirstPlayer,
      });
    }

    // 2. Place tiles
    if (action.targetRow === 'floor') {
      // All tiles to floor
      const { newFloor, discardExcess } = FloorLine.addToFloor(
        player.floorLine,
        taken,
        action.source === 'center' && state.centerHasFirstPlayer && !player.hasFirstPlayer
      );
      // Actually, first player marker was already handled above
      if (player.hasFirstPlayer && !state.players[newState.currentPlayerIndex].hasFirstPlayer) {
        // First player marker goes to floor
        const fpResult = FloorLine.addToFloor(player.floorLine, taken, true);
        player.floorLine = fpResult.newFloor;
        newState.discard.push(...fpResult.discardExcess);
      } else {
        player.floorLine = newFloor;
        newState.discard.push(...discardExcess);
      }

      events.push({
        type: 'TILES_TO_FLOOR',
        count: taken.length,
      });
    } else {
      const row = action.targetRow;
      const placeResult = PatternLine.place(
        player.patternLines[row], taken, action.color, row
      );
      player.patternLines[row] = placeResult.newLine;

      events.push({
        type: 'TILES_PLACED',
        targetRow: row,
        placed: placeResult.placed,
        overflow: placeResult.overflowCount,
      });

      // Overflow to floor
      if (placeResult.overflowCount > 0) {
        const floorTiles = placeResult.overflowTiles;

        // If took first player from center, add marker to floor too
        let addFP = false;
        if (action.source === 'center' && state.centerHasFirstPlayer && player.hasFirstPlayer) {
          addFP = true;
        }

        const { newFloor, discardExcess } = FloorLine.addToFloor(
          player.floorLine, floorTiles, addFP
        );
        player.floorLine = newFloor;
        newState.discard.push(...discardExcess);

        events.push({
          type: 'TILES_TO_FLOOR',
          count: placeResult.overflowCount,
        });
      } else if (action.source === 'center' && state.centerHasFirstPlayer && player.hasFirstPlayer) {
        // First player marker goes to floor with no overflow tiles
        const { newFloor, discardExcess } = FloorLine.addToFloor(
          player.floorLine, [], true
        );
        player.floorLine = newFloor;
        newState.discard.push(...discardExcess);
      }
    }

    // 3. Record turn
    newState.turnHistory.push({
      action: deepCopy(action),
      playerIndex: newState.currentPlayerIndex,
      timestamp: Date.now(),
    });

    // 4. Check if round is over
    if (GameRules.isRoundOver(newState)) {
      newState.phase = 'wall-tiling';
      events.push({ type: 'ROUND_OVER' });
    } else {
      // Advance to next player
      newState.currentPlayerIndex = TurnManager.nextPlayer(newState);
      events.push({
        type: 'NEXT_TURN',
        playerIndex: newState.currentPlayerIndex,
      });
    }

    return { newState, events };
  }

  /**
   * Summer Pavilion action handler (simplified for drafting phase).
   */
  static applySummerAction(state, action) {
    if (action.type === 'draft') {
      return GameState.applySummerDraft(state, action);
    }
    if (action.type === 'place') {
      return GameState.applySummerPlace(state, action);
    }
    if (action.type === 'pass') {
      return GameState.applySummerPass(state, action);
    }
    return { newState: state, events: [{ type: 'INVALID_MOVE', error: 'Unknown action type' }] };
  }

  static applySummerDraft(state, action) {
    const newState = deepCopy(state);
    const events = [];
    const player = newState.players[newState.currentPlayerIndex];
    const wildColor = newState.wildColor;

    let taken;

    if (action.source === 'factory') {
      const pickResult = FactoryDisplay.pickFromFactorySummer(
        newState.factories, action.factoryIndex, action.color, wildColor
      );
      if (!pickResult) {
        return { newState: state, events: [{ type: 'INVALID_MOVE', error: 'Invalid factory pick' }] };
      }
      taken = pickResult.taken;
      newState.factories = pickResult.newFactories;
      newState.center.push(...pickResult.remaining);
    } else {
      const pickResult = FactoryDisplay.pickFromCenterSummer(
        newState.center, action.color, wildColor, newState.centerHasFirstPlayer
      );
      if (!pickResult) {
        return { newState: state, events: [{ type: 'INVALID_MOVE', error: 'Invalid center pick' }] };
      }
      taken = pickResult.taken;
      newState.center = pickResult.newCenter;

      if (pickResult.tookFirstPlayer) {
        player.hasFirstPlayer = true;
        newState.centerHasFirstPlayer = false;
        // Penalty = number of tiles taken
        const penalty = taken.length;
        player.score = Math.max(SUMMER.MIN_SCORE, player.score - penalty);
        events.push({ type: 'FIRST_PLAYER_PENALTY', penalty });
      }
    }

    player.handTiles.push(...taken);
    events.push({
      type: 'TILES_DRAFTED',
      color: action.color,
      count: taken.length,
    });

    newState.turnHistory.push({
      action: deepCopy(action),
      playerIndex: newState.currentPlayerIndex,
      timestamp: Date.now(),
    });

    // Check if drafting phase over
    if (FactoryDisplay.allEmpty(newState.factories, newState.center)) {
      newState.phase = 'placement';
      // Set first player for placement
      for (let i = 0; i < newState.players.length; i++) {
        if (newState.players[i].hasFirstPlayer) {
          newState.currentPlayerIndex = i;
          break;
        }
      }
      events.push({ type: 'PLACEMENT_PHASE_START' });
    } else {
      newState.currentPlayerIndex = TurnManager.nextPlayer(newState);
    }

    return { newState, events };
  }

  static applySummerPlace(state, action) {
    const newState = deepCopy(state);
    const events = [];
    const player = newState.players[newState.currentPlayerIndex];

    const { star, position, color, tilesUsed, wildTilesUsed } = action;
    const cost = position;

    // Validate
    if (!StarBoard.canPlace(player.starBoard, star, position, player.handTiles, newState.wildColor)) {
      return { newState: state, events: [{ type: 'INVALID_MOVE', error: 'Cannot place here' }] };
    }

    // Remove tiles from hand
    let remaining = [...player.handTiles];
    let colorRemoved = 0;
    let wildRemoved = 0;

    for (let i = remaining.length - 1; i >= 0 && colorRemoved < tilesUsed; i--) {
      if (remaining[i] === color) {
        remaining.splice(i, 1);
        colorRemoved++;
      }
    }
    for (let i = remaining.length - 1; i >= 0 && wildRemoved < wildTilesUsed; i--) {
      if (remaining[i] === newState.wildColor) {
        remaining.splice(i, 1);
        wildRemoved++;
      }
    }

    if (colorRemoved + wildRemoved < cost) {
      return { newState: state, events: [{ type: 'INVALID_MOVE', error: 'Not enough tiles' }] };
    }

    player.handTiles = remaining;

    const result = StarBoard.place(
      player.starBoard, star, position, color, tilesUsed, wildTilesUsed
    );
    player.starBoard = result.newBoard;
    player.score += result.score;

    // Discard payment tiles
    for (let i = 0; i < result.discardedTiles; i++) {
      newState.discard.push(color); // simplified
    }

    events.push({
      type: 'TILE_PLACED_STAR',
      star, position, color,
      score: result.score,
      decorations: result.decorationBonuses,
    });

    // Advance to next non-passed player
    GameState.advanceSummerPlacement(newState);

    return { newState, events };
  }

  static applySummerPass(state, action) {
    const newState = deepCopy(state);
    const events = [];
    const player = newState.players[newState.currentPlayerIndex];

    player.hasPassed = true;
    events.push({
      type: 'PLAYER_PASSED',
      playerIndex: newState.currentPlayerIndex,
    });

    // Check if all passed
    if (newState.players.every(p => p.hasPassed)) {
      // Round end
      GameState.processSummerRoundEnd(newState, events);
    } else {
      GameState.advanceSummerPlacement(newState);
    }

    return { newState, events };
  }

  static advanceSummerPlacement(state) {
    let next = (state.currentPlayerIndex + 1) % state.players.length;
    let checks = 0;
    while (state.players[next].hasPassed && checks < state.players.length) {
      next = (next + 1) % state.players.length;
      checks++;
    }

    if (checks >= state.players.length) {
      // All passed — process round end
      const events = [];
      GameState.processSummerRoundEnd(state, events);
    } else {
      state.currentPlayerIndex = next;
    }
  }

  static processSummerRoundEnd(state, events) {
    // Discard excess tiles
    for (const player of state.players) {
      if (player.handTiles && player.handTiles.length > SUMMER.CORNER_STORAGE) {
        const excess = player.handTiles.length - SUMMER.CORNER_STORAGE;
        player.score = Math.max(SUMMER.MIN_SCORE, player.score - excess);
        state.discard.push(...player.handTiles.slice(SUMMER.CORNER_STORAGE));
        player.handTiles = player.handTiles.slice(0, SUMMER.CORNER_STORAGE);
      }
      player.hasPassed = false;
    }

    state.round++;

    if (state.round > SUMMER.ROUNDS) {
      // Game over
      state.phase = 'game-over';
      events.push({ type: 'GAME_OVER' });
    } else {
      // Next round setup
      state.wildColor = SUMMER.WILD_SEQUENCE[state.round - 1];
      state.phase = 'factory-offer';
      state.centerHasFirstPlayer = true;
      state.center = [];

      const bag = TileBag.fromArray(state.bag);
      const factoryCount = FactoryDisplay.getFactoryCount(state.players.length, SUMMER);
      state.factories = FactoryDisplay.fillFactories(
        FactoryDisplay.createFactories(factoryCount),
        bag,
        state.discard,
        SUMMER.TILES_PER_FACTORY
      );
      state.bag = bag.toArray();

      events.push({ type: 'ROUND_START', round: state.round });
    }
  }
}

// === js/ai/Heuristics.js ===
// js/ai/Heuristics.js — Board evaluation functions




class Heuristics {
  /**
   * Evaluate a board position for a player (higher = better).
   */
  static evaluate(state, playerIndex) {
    const player = state.players[playerIndex];
    let score = 0;

    // 1. Current score
    score += player.score * 1.0;

    // 2. Pattern line completion potential
    score += Heuristics.patternLineValue(player) * 0.8;

    // 3. Wall adjacency potential
    score += Heuristics.wallPotential(player.wall) * 0.6;

    // 4. Floor line risk
    const floorPenalty = FloorLine.calculatePenalty(player.floorLine);
    score += floorPenalty * 1.2;

    // 5. End-game bonus progress
    score += Heuristics.endGameProgress(player.wall) * 0.5;

    return score;
  }

  static patternLineValue(player) {
    let value = 0;
    for (let row = 0; row < 5; row++) {
      const line = player.patternLines[row];
      if (line.length === 0) continue;

      const maxSize = row + 1;
      const progress = line.length / maxSize;
      const color = line[0];

      // Value of completing this line
      if (Wall.canPlaceColor(player.wall, row, color)) {
        // Estimate wall score
        const col = Wall.getColumnForColor(row, color);
        value += progress * 2;

        // Higher value if close to completion
        if (progress >= 0.8) value += 1.5;
      }
    }
    return value;
  }

  static wallPotential(wall) {
    let value = 0;

    // Check for rows close to completion
    for (let r = 0; r < 5; r++) {
      const filled = wall[r].filter(c => c !== null).length;
      if (filled >= 3) value += (filled - 2) * 1.5; // Rows with 3+ are valuable
      if (filled === 4) value += 3; // Almost complete row
    }

    // Check columns
    for (let c = 0; c < 5; c++) {
      let filled = 0;
      for (let r = 0; r < 5; r++) {
        if (wall[r][c] !== null) filled++;
      }
      if (filled >= 3) value += (filled - 2) * 1.0;
    }

    return value;
  }

  static endGameProgress(wall) {
    let value = 0;

    // Partial row completion
    for (let r = 0; r < 5; r++) {
      const filled = wall[r].filter(c => c !== null).length;
      if (filled >= 3) value += filled * 0.4; // +2 bonus for complete
    }

    // Partial column completion
    for (let c = 0; c < 5; c++) {
      let filled = 0;
      for (let r = 0; r < 5; r++) {
        if (wall[r][c] !== null) filled++;
      }
      if (filled >= 3) value += filled * 0.6; // +7 bonus for complete
    }

    // Partial color set completion
    for (const color of CLASSIC.COLORS) {
      let count = 0;
      for (let r = 0; r < 5; r++) {
        for (let c = 0; c < 5; c++) {
          if (wall[r][c] === color) count++;
        }
      }
      if (count >= 3) value += count * 0.8; // +10 bonus for complete
    }

    return value;
  }
}

// === js/ai/strategies/EasyAI.js ===
// js/ai/strategies/EasyAI.js — Random legal move


class EasyAI {
  selectMove(state) {
    const moves = GameRules.getLegalMoves(state);
    if (moves.length === 0) return null;
    return moves[Math.floor(Math.random() * moves.length)];
  }

  thinkingDelay() {
    return 500 + Math.random() * 500;
  }
}

// === js/ai/strategies/MediumAI.js ===
// js/ai/strategies/MediumAI.js — Greedy: maximize immediate score






class MediumAI {
  selectMove(state) {
    const moves = GameRules.getLegalMoves(state);
    if (moves.length === 0) return null;

    const player = state.players[state.currentPlayerIndex];
    let bestMove = null;
    let bestScore = -Infinity;

    for (const move of moves) {
      const score = this.evaluateMove(state, move, player);
      if (score > bestScore || (score === bestScore && Math.random() > 0.5)) {
        bestScore = score;
        bestMove = move;
      }
    }

    return bestMove || moves[0];
  }

  evaluateMove(state, move, player) {
    let score = 0;

    // Count tiles taken
    let tileCount;
    if (move.source === 'factory') {
      tileCount = state.factories[move.factoryIndex].filter(t => t === move.color).length;
    } else {
      tileCount = state.center.filter(t => t === move.color).length;
    }

    if (move.targetRow === 'floor') {
      // Simulate floor penalty
      const penalty = this.estimateFloorPenalty(player.floorLine.length + tileCount);
      score = penalty; // Negative
      return score - 5; // Extra penalty to discourage floor dumps
    }

    const row = move.targetRow;
    const maxSize = row + 1;
    const currentFill = player.patternLines[row].length;
    const placeable = Math.min(tileCount, maxSize - currentFill);
    const overflow = tileCount - placeable;

    // Will this complete the pattern line?
    if (currentFill + placeable === maxSize) {
      // Estimate wall score
      const wallCopy = deepCopy(player.wall);
      const col = Wall.getColumnForColor(row, move.color);
      wallCopy[row][col] = move.color;
      const wallScore = Wall.scoreAdjacency(wallCopy, row, col);
      score += wallScore * 2; // High weight for completing
    } else {
      // Partial fill — value progress toward completion
      score += placeable * 0.5;
      // Bonus for getting closer to completion
      const progress = (currentFill + placeable) / maxSize;
      score += progress * 1.5;
    }

    // Penalty for overflow to floor
    if (overflow > 0) {
      const floorPenalty = this.estimateFloorPenalty(player.floorLine.length + overflow);
      const currentPenalty = this.estimateFloorPenalty(player.floorLine.length);
      score += (floorPenalty - currentPenalty);
    }

    // Center pick penalty (first player)
    if (move.source === 'center' && state.centerHasFirstPlayer) {
      score -= 1.5;
    }

    // Denial value (simplified)
    score += this.calculateDenial(state, move) * 0.3;

    return score;
  }

  estimateFloorPenalty(count) {
    let penalty = 0;
    for (let i = 0; i < Math.min(count, 7); i++) {
      penalty += CLASSIC.FLOOR_PENALTIES[i];
    }
    return penalty;
  }

  calculateDenial(state, move) {
    let denialValue = 0;
    const tileCount = move.source === 'factory'
      ? state.factories[move.factoryIndex].filter(t => t === move.color).length
      : state.center.filter(t => t === move.color).length;

    for (let i = 0; i < state.players.length; i++) {
      if (i === state.currentPlayerIndex) continue;
      const opp = state.players[i];

      for (let row = 0; row < 5; row++) {
        const pl = opp.patternLines[row];
        if (pl.length > 0 && pl[0] === move.color) {
          // Opponent needs this color
          const needed = (row + 1) - pl.length;
          denialValue += Math.min(tileCount, needed) * 0.5;
        }
      }
    }

    return denialValue;
  }

  thinkingDelay() {
    return 800 + Math.random() * 700;
  }
}

// === js/ai/strategies/HardAI.js ===
// js/ai/strategies/HardAI.js — Minimax with heuristic eval (depth-limited)





class HardAI {
  constructor() {
    this.maxDepth = 2;
    this.timeLimit = 2000; // ms
    this.startTime = 0;
    this.bestMoveSoFar = null;
  }

  selectMove(state) {
    const moves = GameRules.getLegalMoves(state);
    if (moves.length === 0) return null;
    if (moves.length === 1) return moves[0];

    this.startTime = Date.now();
    this.bestMoveSoFar = moves[0];

    try {
      let bestScore = -Infinity;

      for (const move of moves) {
        if (this.isTimeUp()) break;

        const { newState } = GameState.applyAction(state, move);
        const score = this.minimax(
          newState,
          this.maxDepth - 1,
          -Infinity,
          Infinity,
          false,
          state.currentPlayerIndex
        );

        if (score > bestScore) {
          bestScore = score;
          this.bestMoveSoFar = move;
        }
      }
    } catch (e) {
      // Time ran out or error — return best found so far
    }

    return this.bestMoveSoFar;
  }

  minimax(state, depth, alpha, beta, isMaximizing, aiPlayerIndex) {
    if (this.isTimeUp()) return Heuristics.evaluate(state, aiPlayerIndex);
    if (depth === 0 || state.phase === 'game-over' || state.phase === 'wall-tiling') {
      return Heuristics.evaluate(state, aiPlayerIndex);
    }

    const moves = GameRules.getLegalMoves(state);
    if (moves.length === 0) {
      return Heuristics.evaluate(state, aiPlayerIndex);
    }

    // Limit branching factor for performance
    const limitedMoves = moves.length > 10 ? this.pruneMovesPreliminarily(state, moves).slice(0, 10) : moves;

    if (isMaximizing) {
      let maxEval = -Infinity;
      for (const move of limitedMoves) {
        if (this.isTimeUp()) break;
        const { newState } = GameState.applyAction(state, move);
        const isNextMax = newState.currentPlayerIndex === aiPlayerIndex;
        const evaluation = this.minimax(newState, depth - 1, alpha, beta, isNextMax, aiPlayerIndex);
        maxEval = Math.max(maxEval, evaluation);
        alpha = Math.max(alpha, evaluation);
        if (beta <= alpha) break;
      }
      return maxEval;
    } else {
      let minEval = Infinity;
      for (const move of limitedMoves) {
        if (this.isTimeUp()) break;
        const { newState } = GameState.applyAction(state, move);
        const isNextMax = newState.currentPlayerIndex === aiPlayerIndex;
        const evaluation = this.minimax(newState, depth - 1, alpha, beta, isNextMax, aiPlayerIndex);
        minEval = Math.min(minEval, evaluation);
        beta = Math.min(beta, evaluation);
        if (beta <= alpha) break;
      }
      return minEval;
    }
  }

  pruneMovesPreliminarily(state, moves) {
    // Quick score each move and return sorted
    const medium = new (require('./MediumAI.js').MediumAI || class { evaluateMove() { return 0; } })();
    const player = state.players[state.currentPlayerIndex];

    return moves
      .map(m => ({ move: m, score: this.quickEval(state, m, player) }))
      .sort((a, b) => b.score - a.score)
      .map(ms => ms.move);
  }

  quickEval(state, move, player) {
    // Simple quick evaluation without deep copy
    let score = 0;
    let tileCount;

    if (move.source === 'factory') {
      tileCount = state.factories[move.factoryIndex].filter(t => t === move.color).length;
    } else {
      tileCount = state.center.filter(t => t === move.color).length;
    }

    if (move.targetRow === 'floor') return -10;

    const row = move.targetRow;
    const maxSize = row + 1;
    const currentFill = player.patternLines[row].length;
    const placeable = Math.min(tileCount, maxSize - currentFill);
    const overflow = tileCount - placeable;

    if (currentFill + placeable === maxSize) score += 5;
    else score += placeable * 0.5;

    score -= overflow * 1.5;

    return score;
  }

  isTimeUp() {
    return Date.now() - this.startTime > this.timeLimit;
  }

  thinkingDelay() {
    return 1000 + Math.random() * 1000;
  }
}

// === js/ai/AIPlayer.js ===
// js/ai/AIPlayer.js — AI interface + difficulty dispatcher




const strategies = {
  'ai-easy': () => new EasyAI(),
  'ai-medium': () => new MediumAI(),
  'ai-hard': () => new HardAI(),
};

class AIPlayer {
  static isAI(playerType) {
    return playerType.startsWith('ai-');
  }

  static getStrategy(playerType) {
    const factory = strategies[playerType];
    if (!factory) return new EasyAI(); // Fallback
    return factory();
  }

  static async executeAITurn(state) {
    const player = state.players[state.currentPlayerIndex];
    if (!AIPlayer.isAI(player.type)) return null;

    const strategy = AIPlayer.getStrategy(player.type);
    const move = strategy.selectMove(state);

    if (!move) return null;

    // Artificial thinking delay
    const delay = strategy.thinkingDelay();
    await new Promise(resolve => setTimeout(resolve, delay));

    return move;
  }
}

// === js/variants/VariantRegistry.js ===
// js/variants/VariantRegistry.js — Register/load game variant modules

const variants = new Map();

function registerVariant(config) {
  variants.set(config.id, config);
}

function getVariant(id) {
  return variants.get(id);
}

function listVariants() {
  return Array.from(variants.values()).map(v => ({
    id: v.id,
    name: v.name,
    description: v.description,
    playerRange: v.playerRange,
  }));
}

// === js/variants/ClassicAzul.js ===
// js/variants/ClassicAzul.js — Classic variant config bundle


const ClassicAzulConfig = {
  id: 'classic',
  name: 'Classic Azul',
  description: 'The original tile-laying game. Complete rows on your wall to score!',
  playerRange: [2, 4],

  tileColors: CLASSIC.COLORS,
  tilesPerColor: CLASSIC.TILES_PER_COLOR,
  totalTiles: CLASSIC.TOTAL_TILES,
  tileSetKey: 'classic',

  factoryCount: (playerCount) => CLASSIC.FACTORIES[playerCount] || 5,
  tilesPerFactory: CLASSIC.TILES_PER_FACTORY,

  rounds: 'dynamic',
  endGameTrigger: (state) => state.players.some(p =>
    p.wall.some(row => row.every(cell => cell !== null))
  ),

  startingScore: 0,
  minimumScore: CLASSIC.MIN_SCORE,
  floorPenalties: CLASSIC.FLOOR_PENALTIES,

  boardType: 'grid',
  boardConfig: {
    wallPattern: CLASSIC.WALL_PATTERN,
    patternLines: 5,
    wallSize: 5,
  },

  wildMechanic: null,
  specialRules: {},

  boardCSSFile: 'board.css',
  rendererClass: 'BoardRenderer',
};

// === js/variants/SummerPavilion.js ===
// js/variants/SummerPavilion.js — Summer Pavilion variant config bundle


const SummerPavilionConfig = {
  id: 'summer',
  name: 'Summer Pavilion',
  description: 'A colorful star-board variant with wild tiles and decorations.',
  playerRange: [2, 4],

  tileColors: SUMMER.COLORS,
  tilesPerColor: SUMMER.TILES_PER_COLOR,
  totalTiles: SUMMER.TOTAL_TILES,
  tileSetKey: 'summer',

  factoryCount: (playerCount) => SUMMER.FACTORIES[playerCount] || 5,
  tilesPerFactory: SUMMER.TILES_PER_FACTORY,

  rounds: SUMMER.ROUNDS,
  endGameTrigger: (state) => state.round > SUMMER.ROUNDS,

  startingScore: SUMMER.STARTING_SCORE,
  minimumScore: SUMMER.MIN_SCORE,
  floorPenalties: null,

  boardType: 'star',
  boardConfig: {
    stars: 7,
    positionsPerStar: 6,
    cornerStorage: SUMMER.CORNER_STORAGE,
    supplySpaces: SUMMER.SUPPLY_SPACES,
  },

  wildMechanic: { sequence: SUMMER.WILD_SEQUENCE },
  specialRules: {
    cornerStorage: SUMMER.CORNER_STORAGE,
    starBonuses: SUMMER.STAR_BONUSES,
    numberBonuses: SUMMER.NUMBER_BONUSES,
  },

  boardCSSFile: 'board-summer.css',
  rendererClass: 'StarRenderer',
};

// === js/audio/SoundManager.js ===
// js/audio/SoundManager.js — Sound manager (works with or without Howler.js)

class SoundManagerClass {
  constructor() {
    this.sounds = {};
    this.muted = localStorage.getItem('azul-muted') === 'true';
    this.volume = parseFloat(localStorage.getItem('azul-volume') || '0.5');
    this.audioContext = null;
    this.initialized = false;
  }

  init() {
    if (this.initialized) return;
    this.initialized = true;

    // Create simple audio elements for each sound
    const soundDefs = {
      tilePick: { freq: 800, duration: 0.08, type: 'sine' },
      tilePlace: { freq: 600, duration: 0.1, type: 'sine' },
      tileWall: { freq: 500, duration: 0.15, type: 'triangle' },
      tileBreak: { freq: 300, duration: 0.12, type: 'sawtooth' },
      scoreTick: { freq: 1000, duration: 0.05, type: 'sine' },
      scoreBonus: { freq: 1200, duration: 0.2, type: 'sine' },
      roundEnd: { freq: 700, duration: 0.3, type: 'triangle' },
      gameOver: { freq: 880, duration: 0.5, type: 'sine' },
      turnAlert: { freq: 900, duration: 0.15, type: 'sine' },
      playerJoin: { freq: 660, duration: 0.12, type: 'sine' },
      error: { freq: 200, duration: 0.15, type: 'square' },
    };

    this.soundDefs = soundDefs;
  }

  unlock() {
    try {
      if (!this.audioContext) {
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (this.audioContext.state === 'suspended') {
        this.audioContext.resume();
      }
    } catch (e) {
      // Audio not supported
    }
  }

  play(soundName) {
    if (this.muted || !this.audioContext) return;

    const def = this.soundDefs?.[soundName];
    if (!def) return;

    try {
      const osc = this.audioContext.createOscillator();
      const gain = this.audioContext.createGain();

      osc.type = def.type;
      osc.frequency.setValueAtTime(def.freq, this.audioContext.currentTime);

      gain.gain.setValueAtTime(this.volume * 0.3, this.audioContext.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + def.duration);

      osc.connect(gain);
      gain.connect(this.audioContext.destination);

      osc.start(this.audioContext.currentTime);
      osc.stop(this.audioContext.currentTime + def.duration);
    } catch (e) {
      // Ignore audio errors
    }
  }

  toggleMute() {
    this.muted = !this.muted;
    localStorage.setItem('azul-muted', this.muted);
    return this.muted;
  }

  setVolume(vol) {
    this.volume = Math.max(0, Math.min(1, vol));
    localStorage.setItem('azul-volume', this.volume);
  }

  isMuted() {
    return this.muted;
  }
}

const SoundManager = new SoundManagerClass();

// === js/ui/ToastNotifications.js ===
// js/ui/ToastNotifications.js — Toast notifications

class ToastNotifications {
  constructor() {
    this.container = null;
    this.init();
  }

  init() {
    this.container = document.getElementById('toast-container');
    if (!this.container) {
      this.container = document.createElement('div');
      this.container.id = 'toast-container';
      this.container.className = 'toast-container';
      this.container.setAttribute('aria-live', 'polite');
      this.container.setAttribute('aria-atomic', 'true');
      document.body.appendChild(this.container);
    }
  }

  show(message, type = 'info', duration = 2800) {
    const toast = document.createElement('div');
    toast.className = `toast toast--${type}`;
    toast.textContent = message;

    this.container.appendChild(toast);

    setTimeout(() => {
      if (toast.parentElement) {
        toast.remove();
      }
    }, duration);
  }

  info(message) { this.show(message, 'info'); }
  error(message) { this.show(message, 'error'); }
  success(message) { this.show(message, 'success'); }
  turn(playerName) { this.show(`${playerName}'s turn`, 'info', 2000); }
}

// === js/ui/Renderer.js ===
// js/ui/Renderer.js — Master renderer: orchestrates all sub-renderers





class Renderer {
  constructor(gameApp) {
    this.app = gameApp;
    this.gameContainer = document.getElementById('game-container');
    this.selectedSource = null;
    this.selectedColor = null;
    this.selectedFactoryIndex = null;
    this.legalTargetRows = [];
  }

  // ========== Create tile element ==========
  createTileElement(color, extraClasses = '') {
    const div = document.createElement('div');
    div.className = `tile tile--${color} ${extraClasses}`.trim();
    div.setAttribute('aria-label', `${color} tile`);
    div.dataset.color = color;
    return div;
  }

  // ========== SCORE BAR ==========
  renderScoreBar(state) {
    const bar = document.getElementById('score-bar');
    if (!bar) return;

    bar.innerHTML = '';

    const roundEl = document.createElement('span');
    roundEl.className = 'score-bar__round';
    roundEl.textContent = `R${state.round}`;
    bar.appendChild(roundEl);

    state.players.forEach((player, i) => {
      const playerEl = document.createElement('button');
      playerEl.className = 'score-bar__player';
      if (i === state.currentPlayerIndex) playerEl.classList.add('score-bar__player--current');

      const nameEl = document.createElement('span');
      nameEl.className = 'score-bar__name';
      nameEl.textContent = player.name;

      const scoreEl = document.createElement('span');
      scoreEl.className = 'score-bar__score';
      scoreEl.textContent = player.score;

      playerEl.appendChild(nameEl);
      playerEl.appendChild(scoreEl);
      playerEl.onclick = () => this.scrollToPlayer(i);
      bar.appendChild(playerEl);
    });

    const settingsBtn = document.createElement('button');
    settingsBtn.className = 'score-bar__settings';
    settingsBtn.textContent = '⚙️';
    settingsBtn.setAttribute('aria-label', 'Settings');
    settingsBtn.onclick = () => this.app.toggleSettings();
    bar.appendChild(settingsBtn);
  }

  // ========== MARKET SECTION (Factories + Center) ==========
  renderMarket(state) {
    const section = document.getElementById('market-section');
    if (!section) return;

    const marketArea = section.querySelector('.market-area') || document.createElement('div');
    marketArea.className = 'market-area';
    marketArea.innerHTML = '';

    // Factory ring
    const ring = document.createElement('div');
    ring.className = 'factory-ring';

    const factoryCount = state.factories.length;
    const containerSize = marketArea.offsetWidth || 340;
    const radius = containerSize * 0.38;
    const cx = containerSize / 2;
    const cy = containerSize / 2;

    state.factories.forEach((factory, fi) => {
      const angle = (2 * Math.PI * fi / factoryCount) - Math.PI / 2;
      const x = cx + radius * Math.cos(angle);
      const y = cy + radius * Math.sin(angle);

      const factoryEl = document.createElement('div');
      factoryEl.className = `factory ${factory.length === 0 ? 'factory--empty' : ''}`;
      factoryEl.style.left = `${x}px`;
      factoryEl.style.top = `${y}px`;
      factoryEl.dataset.factoryIndex = fi;

      factory.forEach(color => {
        const tile = this.createTileElement(color);
        tile.dataset.source = 'factory';
        tile.dataset.factoryIndex = fi;
        tile.onclick = () => this.handleTileClick('factory', fi, color);

        // Highlight if this color is selected in this factory
        if (this.selectedSource === 'factory' && this.selectedFactoryIndex === fi && this.selectedColor === color) {
          tile.classList.add('tile--selected');
        }
        factoryEl.appendChild(tile);
      });

      ring.appendChild(factoryEl);
    });

    marketArea.appendChild(ring);

    // Center pool
    const centerPool = document.createElement('div');
    centerPool.className = `center-pool ${state.center.length > 0 ? 'center-pool--has-tiles' : ''}`;

    if (state.centerHasFirstPlayer) {
      const fpTile = document.createElement('div');
      fpTile.className = 'tile tile--first-player';
      fpTile.style.width = `calc(var(--tile-size) * 0.75)`;
      fpTile.style.height = `calc(var(--tile-size) * 0.75)`;
      centerPool.appendChild(fpTile);
    }

    state.center.forEach(color => {
      const tile = this.createTileElement(color);
      tile.style.width = `calc(var(--tile-size) * 0.75)`;
      tile.style.height = `calc(var(--tile-size) * 0.75)`;
      tile.dataset.source = 'center';
      tile.onclick = () => this.handleTileClick('center', null, color);

      if (this.selectedSource === 'center' && this.selectedColor === color) {
        tile.classList.add('tile--selected');
      }
      centerPool.appendChild(tile);
    });

    marketArea.appendChild(centerPool);

    if (!section.contains(marketArea)) {
      section.appendChild(marketArea);
    }

    // Turn indicator
    let turnInd = section.querySelector('.turn-indicator');
    if (!turnInd) {
      turnInd = document.createElement('div');
      turnInd.className = 'turn-indicator';
      section.appendChild(turnInd);
    }

    const currentPlayer = state.players[state.currentPlayerIndex];
    if (state.phase === 'factory-offer') {
      turnInd.innerHTML = `<span class="turn-indicator__name">${currentPlayer.name}</span>'s turn`;
    } else if (state.phase === 'wall-tiling') {
      turnInd.textContent = 'Scoring...';
    }
  }

  // ========== PLAYER BOARD ==========
  renderPlayerBoard(state, playerIndex = null) {
    if (playerIndex === null) {
      // Find the human player, or use currentPlayerIndex
      playerIndex = state.players.findIndex(p => p.type === 'human');
      if (playerIndex === -1) playerIndex = 0;
    }

    const section = document.getElementById('board-section');
    if (!section) return;
    section.innerHTML = '';

    const player = state.players[playerIndex];
    const board = document.createElement('div');
    board.className = 'player-board';

    // Header
    const header = document.createElement('div');
    header.className = 'board-header';
    header.innerHTML = `
      <span class="board-header__name">${player.name}</span>
      <span class="board-header__score" aria-label="Score: ${player.score}">${player.score}</span>
    `;
    board.appendChild(header);

    // Board grid: pattern lines + wall
    const grid = document.createElement('div');
    grid.className = 'board-grid';

    // Pattern lines
    const patternLinesEl = document.createElement('div');
    patternLinesEl.className = 'pattern-lines';

    for (let row = 0; row < 5; row++) {
      const lineEl = document.createElement('div');
      lineEl.className = 'pattern-line';
      lineEl.dataset.row = row;

      const maxSize = row + 1;
      const line = player.patternLines[row];

      // Is this row a legal target?
      const isLegal = this.legalTargetRows.includes(row) && playerIndex === state.currentPlayerIndex;
      if (isLegal) lineEl.classList.add('pattern-line--legal');

      // Render empty slots + filled tiles (right-aligned)
      const emptyCount = maxSize - line.length;
      for (let s = 0; s < emptyCount; s++) {
        const slot = document.createElement('div');
        slot.className = `tile-slot ${isLegal ? 'tile-slot--legal' : ''}`;
        lineEl.appendChild(slot);
      }
      for (let s = 0; s < line.length; s++) {
        lineEl.appendChild(this.createTileElement(line[s]));
      }

      if (isLegal) {
        lineEl.onclick = () => this.handleTargetClick(row);
      }

      patternLinesEl.appendChild(lineEl);
    }
    grid.appendChild(patternLinesEl);

    // Arrows
    const arrows = document.createElement('div');
    arrows.className = 'board-arrow';
    for (let i = 0; i < 5; i++) {
      const arrow = document.createElement('span');
      arrow.className = 'board-arrow__icon';
      arrow.textContent = '→';
      arrows.appendChild(arrow);
    }
    grid.appendChild(arrows);

    // Wall
    const wallGrid = document.createElement('div');
    wallGrid.className = 'wall-grid';

    for (let r = 0; r < 5; r++) {
      for (let c = 0; c < 5; c++) {
        const cell = document.createElement('div');
        cell.className = 'wall-cell';

        if (player.wall[r][c]) {
          // Placed tile
          const tile = this.createTileElement(player.wall[r][c], 'tile--ghost tile--placed');
          cell.appendChild(tile);
        } else {
          // Ghost tile showing where colors go
          const ghostColor = CLASSIC.WALL_PATTERN[r][c];
          const ghost = this.createTileElement(ghostColor, 'tile--ghost');
          cell.appendChild(ghost);
        }

        wallGrid.appendChild(cell);
      }
    }
    grid.appendChild(wallGrid);
    board.appendChild(grid);

    // Floor line
    const floorEl = document.createElement('div');
    floorEl.className = `floor-line ${this.legalTargetRows.includes('floor') ? 'floor-line--legal' : ''}`;

    const floorLabel = document.createElement('span');
    floorLabel.className = 'floor-line__label';
    floorLabel.textContent = 'Floor';
    floorEl.appendChild(floorLabel);

    for (let i = 0; i < 7; i++) {
      const slot = document.createElement('div');
      slot.className = 'floor-slot';

      if (i < player.floorLine.length) {
        const tile = player.floorLine[i] === 'first-player'
          ? (() => { const t = document.createElement('div'); t.className = 'tile tile--first-player floor-slot__tile'; return t; })()
          : this.createTileElement(player.floorLine[i]);
        if (tile.style) tile.style.width = tile.style.height = '';
        tile.classList.add('floor-slot__tile');
        slot.appendChild(tile);
      } else {
        const empty = document.createElement('div');
        empty.className = 'floor-slot__tile';
        slot.appendChild(empty);
      }

      const penalty = document.createElement('span');
      penalty.className = 'floor-slot__penalty';
      penalty.textContent = CLASSIC.FLOOR_PENALTIES[i];
      slot.appendChild(penalty);

      floorEl.appendChild(slot);
    }

    if (this.legalTargetRows.includes('floor')) {
      floorEl.onclick = () => this.handleTargetClick('floor');
    }

    board.appendChild(floorEl);
    section.appendChild(board);
  }

  // ========== OPPONENT BOARDS ==========
  renderOpponentBoards(state) {
    const section = document.getElementById('opponents-section');
    if (!section) return;
    section.innerHTML = '';

    const label = document.createElement('div');
    label.className = 'opponents-label';
    label.textContent = 'Other Players';
    section.appendChild(label);

    const container = document.createElement('div');
    container.className = 'opponent-boards';

    const humanIdx = state.players.findIndex(p => p.type === 'human');
    const mainPlayerIdx = humanIdx !== -1 ? humanIdx : 0;

    state.players.forEach((player, i) => {
      if (i === mainPlayerIdx) return;

      const board = document.createElement('div');
      board.className = 'opponent-board';

      const header = document.createElement('div');
      header.className = 'opponent-board__header';
      header.innerHTML = `
        <span class="opponent-board__name">${player.name}${i === state.currentPlayerIndex ? ' ★' : ''}</span>
        <span class="opponent-board__score">${player.score}</span>
      `;
      board.appendChild(header);

      // Mini wall
      const miniWall = document.createElement('div');
      miniWall.className = 'mini-wall';
      for (let r = 0; r < 5; r++) {
        for (let c = 0; c < 5; c++) {
          const cell = document.createElement('div');
          cell.className = 'mini-wall__cell';
          if (player.wall[r][c]) {
            cell.classList.add('mini-wall__cell--filled');
            cell.style.background = `var(--tile-${player.wall[r][c]})`;
          }
          miniWall.appendChild(cell);
        }
      }
      board.appendChild(miniWall);

      // Mini floor
      const miniFloor = document.createElement('div');
      miniFloor.className = 'mini-floor';
      for (let j = 0; j < 7; j++) {
        const slot = document.createElement('div');
        slot.className = `mini-floor__slot ${j < player.floorLine.length ? 'mini-floor__slot--filled' : ''}`;
        miniFloor.appendChild(slot);
      }
      board.appendChild(miniFloor);

      container.appendChild(board);
    });

    section.appendChild(container);
  }

  // ========== INTERACTION HANDLERS ==========
  handleTileClick(source, factoryIndex, color) {
    if (this.app.state.phase !== 'factory-offer') return;

    const currentPlayer = this.app.state.players[this.app.state.currentPlayerIndex];
    if (currentPlayer.type !== 'human') return;

    // If clicking same selection, deselect
    if (this.selectedSource === source &&
        this.selectedColor === color &&
        this.selectedFactoryIndex === factoryIndex) {
      this.clearSelection();
      this.app.render();
      return;
    }

    this.selectedSource = source;
    this.selectedColor = color;
    this.selectedFactoryIndex = factoryIndex;

    // Compute legal target rows
    this.legalTargetRows = [];
    for (let row = 0; row < 5; row++) {
      if (PatternLine.canPlace(currentPlayer.patternLines[row], color, row, currentPlayer.wall)) {
        this.legalTargetRows.push(row);
      }
    }
    this.legalTargetRows.push('floor'); // Always legal

    this.app.playSound('tilePick');
    this.app.render();
  }

  handleTargetClick(targetRow) {
    if (!this.selectedColor) return;

    const action = {
      source: this.selectedSource,
      factoryIndex: this.selectedFactoryIndex,
      color: this.selectedColor,
      targetRow,
    };

    this.clearSelection();
    this.app.playSound('tilePlace');
    this.app.handlePlayerAction(action);
  }

  clearSelection() {
    this.selectedSource = null;
    this.selectedColor = null;
    this.selectedFactoryIndex = null;
    this.legalTargetRows = [];
  }

  scrollToPlayer(playerIndex) {
    const section = document.getElementById('board-section');
    if (section) section.scrollIntoView({ behavior: 'smooth' });
  }

  // ========== GAME OVER SCREEN ==========
  renderGameOver(state, result) {
    const overlay = document.createElement('div');
    overlay.className = 'game-over-overlay';
    overlay.id = 'game-over-overlay';

    const crown = document.createElement('div');
    crown.className = 'game-over__crown';
    crown.textContent = '👑';
    overlay.appendChild(crown);

    const title = document.createElement('h2');
    title.className = 'game-over__title';
    title.textContent = result.isTie ? 'Shared Victory!' : 'Game Over!';
    overlay.appendChild(title);

    const winnerText = document.createElement('p');
    winnerText.className = 'game-over__winner';
    const winnerNames = result.winners.map(i => state.players[i].name).join(' & ');
    winnerText.textContent = result.isTie ? `${winnerNames} win!` : `${winnerNames} wins!`;
    overlay.appendChild(winnerText);

    const scoresDiv = document.createElement('div');
    scoresDiv.className = 'game-over__scores';

    result.rankings.forEach((r, rank) => {
      const playerDiv = document.createElement('div');
      playerDiv.className = `game-over__player ${result.winners.includes(r.index) ? 'game-over__player--winner' : ''}`;

      playerDiv.innerHTML = `
        <span class="game-over__rank">${rank + 1}</span>
        <span class="game-over__player-name">${r.name}</span>
        <div>
          <span class="game-over__player-score">${r.score}</span>
          ${state.players[r.index].endGameBonus ? `<div class="game-over__bonus-detail">+${state.players[r.index].endGameBonus} bonus</div>` : ''}
        </div>
      `;
      scoresDiv.appendChild(playerDiv);
    });
    overlay.appendChild(scoresDiv);

    const actions = document.createElement('div');
    actions.className = 'game-over__actions';

    const playAgainBtn = document.createElement('button');
    playAgainBtn.className = 'btn btn-gold';
    playAgainBtn.textContent = 'Play Again';
    playAgainBtn.onclick = () => this.app.playAgain();
    actions.appendChild(playAgainBtn);

    const lobbyBtn = document.createElement('button');
    lobbyBtn.className = 'btn btn-secondary';
    lobbyBtn.textContent = 'Lobby';
    lobbyBtn.onclick = () => this.app.goToLobby();
    actions.appendChild(lobbyBtn);

    overlay.appendChild(actions);
    document.body.appendChild(overlay);
  }

  removeGameOver() {
    const overlay = document.getElementById('game-over-overlay');
    if (overlay) overlay.remove();
  }

  // ========== ROUND TRANSITION ==========
  showRoundTransition(round) {
    const overlay = document.createElement('div');
    overlay.className = 'round-overlay';
    overlay.id = 'round-overlay';
    overlay.innerHTML = `
      <div class="round-overlay__text">Round ${round}</div>
      <div class="round-overlay__sub">Get ready!</div>
    `;
    document.body.appendChild(overlay);

    setTimeout(() => {
      const el = document.getElementById('round-overlay');
      if (el) el.remove();
    }, 1500);
  }

  // ========== FULL RENDER ==========
  render(state) {
    this.renderScoreBar(state);
    this.renderMarket(state);
    this.renderPlayerBoard(state);
    this.renderOpponentBoards(state);
  }
}

// === js/main.js ===
// js/main.js — Main application entry point












class AzulApp {
  constructor() {
    this.state = null;
    this.renderer = null;
    this.toast = null;
    this.currentView = 'lobby'; // 'lobby' | 'game'
    this.aiThinking = false;
    this.gameConfig = {
      variant: 'classic',
      players: [
        { name: 'You', type: 'human' },
        { name: 'Claude', type: 'ai-medium' },
      ],
    };

    // Register variants
    registerVariant(ClassicAzulConfig);
    registerVariant(SummerPavilionConfig);
  }

  init() {
    SoundManager.init();
    this.toast = new ToastNotifications();

    // Check for join link
    const params = new URLSearchParams(window.location.search);
    if (params.has('join')) {
      // Multiplayer join — not yet implemented, show lobby
      this.toast.info('Multiplayer coming soon! Starting local game...');
    }

    // Unlock audio on first touch
    const unlockAudio = () => {
      SoundManager.unlock();
      document.removeEventListener('touchstart', unlockAudio);
      document.removeEventListener('click', unlockAudio);
    };
    document.addEventListener('touchstart', unlockAudio, { once: true });
    document.addEventListener('click', unlockAudio, { once: true });

    this.showLobby();
  }

  // ========== LOBBY ==========
  showLobby() {
    this.currentView = 'lobby';
    const app = document.getElementById('app');
    app.innerHTML = this.buildLobbyHTML();
    this.bindLobbyEvents();
    this.updateLobbyUI();
  }

  buildLobbyHTML() {
    return `
      <div class="lobby" id="lobby">
        <div class="lobby__header">
          <h1 class="lobby__title">AZUL</h1>
          <p class="lobby__subtitle">Portuguese Tile Game</p>
          <div class="lobby__tiles-decor">
            <div class="tile tile--blue"></div>
            <div class="tile tile--yellow"></div>
            <div class="tile tile--red"></div>
            <div class="tile tile--black"></div>
            <div class="tile tile--white"></div>
          </div>
        </div>

        <div class="lobby__panel">
          <div class="lobby__section">
            <div class="lobby__section-title">Game Mode</div>
            <div class="variant-cards" id="variant-cards">
              <button class="variant-card selected" data-variant="classic">
                <div class="variant-card__name">Classic</div>
                <div class="variant-card__desc">Complete wall rows</div>
              </button>
              <button class="variant-card" data-variant="summer">
                <div class="variant-card__name">Summer Pavilion</div>
                <div class="variant-card__desc">Star board variant</div>
              </button>
            </div>
          </div>

          <div class="lobby__section">
            <div class="lobby__section-title">Players</div>
            <div class="player-slots" id="player-slots"></div>
            <button class="add-player-btn" id="add-player-btn">+ Add Player</button>
          </div>

          <button class="btn btn-gold lobby__start" id="start-game-btn">
            Start Game
          </button>
        </div>

        <div class="lobby__footer">
          <div class="lobby__footer-links">
            <button id="rules-btn">How to Play</button>
            <button id="settings-link-btn">Settings</button>
          </div>
        </div>
      </div>
    `;
  }

  bindLobbyEvents() {
    // Variant selection
    document.querySelectorAll('.variant-card').forEach(card => {
      card.onclick = () => {
        document.querySelectorAll('.variant-card').forEach(c => c.classList.remove('selected'));
        card.classList.add('selected');
        this.gameConfig.variant = card.dataset.variant;
        SoundManager.play('tilePick');
      };
    });

    // Add player
    document.getElementById('add-player-btn').onclick = () => {
      if (this.gameConfig.players.length < 4) {
        const num = this.gameConfig.players.length + 1;
        this.gameConfig.players.push({
          name: `CPU ${num - 1}`,
          type: 'ai-easy',
        });
        this.updateLobbyUI();
        SoundManager.play('tilePlace');
      }
    };

    // Start game
    document.getElementById('start-game-btn').onclick = () => {
      this.startGame();
    };

    // Rules
    document.getElementById('rules-btn').onclick = () => {
      this.showRulesDialog();
    };
  }

  updateLobbyUI() {
    const slotsEl = document.getElementById('player-slots');
    if (!slotsEl) return;
    slotsEl.innerHTML = '';

    this.gameConfig.players.forEach((player, i) => {
      const slot = document.createElement('div');
      slot.className = 'player-slot';

      slot.innerHTML = `
        <div class="player-slot__number">${i + 1}</div>
        <input class="player-slot__name" value="${player.name}" data-index="${i}"
               placeholder="Player ${i + 1}" maxlength="12" aria-label="Player ${i+1} name">
        <select class="player-slot__type" data-index="${i}" aria-label="Player ${i+1} type">
          <option value="human" ${player.type === 'human' ? 'selected' : ''}>Human</option>
          <option value="ai-easy" ${player.type === 'ai-easy' ? 'selected' : ''}>AI Easy</option>
          <option value="ai-medium" ${player.type === 'ai-medium' ? 'selected' : ''}>AI Medium</option>
          <option value="ai-hard" ${player.type === 'ai-hard' ? 'selected' : ''}>AI Hard</option>
        </select>
        ${i > 1 ? `<button class="player-slot__remove" data-index="${i}" aria-label="Remove player">✕</button>` : ''}
      `;

      slotsEl.appendChild(slot);
    });

    // Bind slot events
    slotsEl.querySelectorAll('.player-slot__name').forEach(input => {
      input.oninput = () => {
        this.gameConfig.players[input.dataset.index].name = input.value || `Player ${+input.dataset.index + 1}`;
      };
    });

    slotsEl.querySelectorAll('.player-slot__type').forEach(select => {
      select.onchange = () => {
        this.gameConfig.players[select.dataset.index].type = select.value;
      };
    });

    slotsEl.querySelectorAll('.player-slot__remove').forEach(btn => {
      btn.onclick = () => {
        this.gameConfig.players.splice(btn.dataset.index, 1);
        this.updateLobbyUI();
        SoundManager.play('tileBreak');
      };
    });

    // Hide add button if max players
    const addBtn = document.getElementById('add-player-btn');
    if (addBtn) addBtn.style.display = this.gameConfig.players.length >= 4 ? 'none' : '';
  }

  showRulesDialog() {
    const overlay = document.createElement('div');
    overlay.className = 'settings-overlay visible';
    overlay.id = 'rules-overlay';

    overlay.innerHTML = `
      <div class="settings-panel" style="max-height: 80vh; overflow-y: auto;">
        <h3>How to Play</h3>
        <div style="font-size: 0.85rem; color: var(--text-secondary); line-height: 1.7;">
          <p><strong style="color: var(--accent-gold);">Goal:</strong> Score the most points by placing tiles on your wall.</p>
          <p style="margin-top:8px"><strong style="color: var(--accent-gold);">Each Round:</strong></p>
          <p>1. <strong>Draft tiles</strong> — Tap a color on any factory to take ALL tiles of that color. Others go to center.</p>
          <p>2. <strong>Place tiles</strong> — Choose a pattern line row to fill. Overflow goes to your floor (penalties!).</p>
          <p>3. <strong>Score</strong> — Completed rows slide to your wall. Score points for adjacent tiles.</p>
          <p style="margin-top:8px"><strong style="color: var(--accent-gold);">Game End:</strong> When someone completes a wall row. Bonus points for complete rows (+2), columns (+7), and color sets (+10).</p>
          <p style="margin-top:8px"><strong style="color: var(--accent-gold);">Tips:</strong> Plan ahead! Watch what opponents need. Avoid floor penalties.</p>
        </div>
        <button class="btn btn-secondary" style="width:100%;margin-top:16px" onclick="this.closest('.settings-overlay').remove()">Got it!</button>
      </div>
    `;

    document.body.appendChild(overlay);
    overlay.onclick = (e) => {
      if (e.target === overlay) overlay.remove();
    };
  }

  // ========== GAME ==========
  startGame() {
    this.state = GameState.create(this.gameConfig);
    this.currentView = 'game';

    const app = document.getElementById('app');
    app.innerHTML = this.buildGameHTML();

    this.renderer = new Renderer(this);
    this.render();

    SoundManager.play('roundEnd');
    this.toast.info(`Round 1 — ${this.state.players[0].name} starts!`);

    // If first player is AI, trigger AI turn
    this.checkAITurn();
  }

  buildGameHTML() {
    return `
      <div class="game-container" id="game-container">
        <div class="score-bar" id="score-bar" role="status"></div>

        <div class="game-scroll-container" id="game-scroll">
          <div class="game-section market-section" id="market-section">
          </div>

          <div class="game-section board-section" id="board-section">
          </div>

          <div class="game-section opponents-section" id="opponents-section">
          </div>
        </div>

        <div class="section-nav" id="section-nav">
          <button class="section-nav__dot section-nav__dot--active" data-section="market" aria-label="Market"></button>
          <button class="section-nav__dot" data-section="board" aria-label="Your board"></button>
          <button class="section-nav__dot" data-section="opponents" aria-label="Opponents"></button>
        </div>
      </div>

      <div class="settings-overlay" id="settings-overlay">
        <div class="settings-panel">
          <h3>Settings</h3>
          <div class="setting-row">
            <span class="setting-label">Sound</span>
            <div class="toggle ${SoundManager.isMuted() ? '' : 'active'}" id="sound-toggle"></div>
          </div>
          <div class="setting-row">
            <span class="setting-label">Haptics</span>
            <div class="toggle active" id="haptic-toggle"></div>
          </div>
          <button class="btn btn-secondary" style="width:100%;margin-top:16px" id="close-settings">Close</button>
          <button class="btn btn-secondary" style="width:100%;margin-top:8px;color:var(--danger)" id="quit-game">Quit to Lobby</button>
        </div>
      </div>
    `;
  }

  render() {
    if (!this.renderer || !this.state) return;
    this.renderer.render(this.state);
    this.bindGameEvents();
  }

  bindGameEvents() {
    // Section nav
    document.querySelectorAll('.section-nav__dot').forEach(dot => {
      dot.onclick = () => {
        const sectionId = `${dot.dataset.section}-section`;
        document.getElementById(sectionId)?.scrollIntoView({ behavior: 'smooth' });
      };
    });

    // Scroll observer for nav dots
    const scroll = document.getElementById('game-scroll');
    if (scroll && !scroll.dataset.observed) {
      scroll.dataset.observed = 'true';
      const sections = scroll.querySelectorAll('.game-section');
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const id = entry.target.id.replace('-section', '');
            document.querySelectorAll('.section-nav__dot').forEach(d => {
              d.classList.toggle('section-nav__dot--active', d.dataset.section === id);
            });
          }
        });
      }, { root: scroll, threshold: 0.5 });
      sections.forEach(s => observer.observe(s));
    }

    // Settings
    document.getElementById('close-settings')?.addEventListener('click', () => {
      this.toggleSettings(false);
    });

    document.getElementById('sound-toggle')?.addEventListener('click', (e) => {
      const muted = SoundManager.toggleMute();
      e.currentTarget.classList.toggle('active', !muted);
    });

    document.getElementById('quit-game')?.addEventListener('click', () => {
      this.goToLobby();
    });
  }

  toggleSettings(show) {
    const overlay = document.getElementById('settings-overlay');
    if (!overlay) return;
    if (show === undefined) show = !overlay.classList.contains('visible');
    overlay.classList.toggle('visible', show);
  }

  // ========== GAME ACTIONS ==========
  async handlePlayerAction(action) {
    if (this.aiThinking) return;
    if (this.state.phase !== 'factory-offer') return;

    const { newState, events } = GameState.applyAction(this.state, action);

    // Check for invalid move
    const invalidEvent = events.find(e => e.type === 'INVALID_MOVE');
    if (invalidEvent) {
      this.toast.error(invalidEvent.error);
      SoundManager.play('error');
      this.haptic('error');
      return;
    }

    this.state = newState;

    // Process events
    this.processEvents(events);

    // Check if we need wall tiling
    if (this.state.phase === 'wall-tiling') {
      await this.processRoundEnd();
      return;
    }

    this.render();

    // Check if next player is AI
    await this.checkAITurn();
  }

  async processRoundEnd() {
    this.toast.info('Scoring round...');
    SoundManager.play('roundEnd');

    // Small delay for visual feedback
    await this.delay(600);

    const result = TurnManager.processRoundEnd(this.state);
    this.state = result.newState;

    // Process wall tiling events
    this.processEvents(result.events);

    if (result.gameOver) {
      await this.delay(500);
      this.handleGameOver();
      return;
    }

    // Show round transition
    this.renderer.showRoundTransition(this.state.round);
    this.render();

    await this.delay(1600);

    this.toast.info(`Round ${this.state.round} — ${this.state.players[this.state.currentPlayerIndex].name} starts!`);

    // Check if first player is AI
    await this.checkAITurn();
  }

  handleGameOver() {
    this.state.phase = 'game-over';
    const result = GameRules.determineWinner(this.state);

    this.render();
    SoundManager.play('gameOver');
    this.renderer.renderGameOver(this.state, result);
  }

  async checkAITurn() {
    while (
      this.state.phase === 'factory-offer' &&
      AIPlayer.isAI(this.state.players[this.state.currentPlayerIndex].type)
    ) {
      this.aiThinking = true;
      this.render();

      const move = await AIPlayer.executeAITurn(this.state);
      if (!move) {
        this.aiThinking = false;
        break;
      }

      const { newState, events } = GameState.applyAction(this.state, move);
      this.state = newState;
      this.processEvents(events);

      // Check for wall tiling
      if (this.state.phase === 'wall-tiling') {
        this.aiThinking = false;
        await this.processRoundEnd();
        return;
      }

      this.render();
    }

    this.aiThinking = false;
    this.render();
  }

  processEvents(events) {
    for (const event of events) {
      switch (event.type) {
        case 'FIRST_PLAYER_TAKEN':
          SoundManager.play('tileBreak');
          break;
        case 'TILES_PICKED':
          SoundManager.play('tilePick');
          break;
        case 'TILES_PLACED':
          SoundManager.play('tilePlace');
          break;
        case 'TILES_TO_FLOOR':
          SoundManager.play('tileBreak');
          break;
        case 'PLAYER_WALL_TILING':
          if (event.events) {
            for (const subEvent of event.events) {
              if (subEvent.type === 'TILE_SCORED') {
                SoundManager.play('tileWall');
              }
            }
          }
          break;
        case 'NEXT_TURN':
          // Show turn notification for human players
          const nextPlayer = this.state.players[event.playerIndex];
          if (nextPlayer.type === 'human') {
            this.toast.turn(nextPlayer.name);
            SoundManager.play('turnAlert');
            this.haptic('tile-pick');
          }
          break;
        case 'END_GAME_BONUS':
          SoundManager.play('scoreBonus');
          break;
      }
    }
  }

  // ========== UTILITIES ==========
  playSound(name) {
    SoundManager.play(name);
  }

  haptic(type) {
    if (!navigator.vibrate) return;
    switch (type) {
      case 'tile-pick': navigator.vibrate(15); break;
      case 'tile-place': navigator.vibrate(25); break;
      case 'score': navigator.vibrate([10, 50, 10]); break;
      case 'error': navigator.vibrate([50, 30, 50]); break;
    }
  }

  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  playAgain() {
    this.renderer.removeGameOver();
    this.startGame();
  }

  goToLobby() {
    this.renderer?.removeGameOver();
    this.state = null;
    this.renderer = null;
    this.showLobby();
  }
}

// ========== INITIALIZATION ==========
function bootstrap() {
  const app = new AzulApp();
  window.azulApp = app; // Debug access
  app.init();
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', bootstrap);
} else {
  bootstrap();
}

  </script>
  <script>
    const loader = document.getElementById('loading');
    if (loader) setTimeout(() => loader.remove(), 300);
  </script>
</body>
</html>
